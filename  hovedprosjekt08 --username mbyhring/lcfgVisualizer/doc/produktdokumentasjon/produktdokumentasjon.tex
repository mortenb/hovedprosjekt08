\documentclass[12pt,a4paper]{report}
\usepackage[latin1]{inputenc}
\usepackage[norsk]{babel}
\usepackage{verbatim}
\usepackage{alltt}
\usepackage{graphicx}

% to reduce indent
\setlength{\parindent}{0pt}
%\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}
%

\title{Produktdokumentasjon}
\begin{document}

\section*{Forord}
Her kommer forordet. Hvem er dette for osv
\newpage
\setlength{\parskip}{0ex}
\tableofcontents
\setlength{\parskip}{2ex plus 0.5ex minus 0.2ex}\newpage


\chapter{Beskrivelse av programmet}
Hva det gjør?
LCFGvisualizer er et program som gjør om masse tekst til et 3d-bilde.

\section{Teknologi}
De forskjellige teknologiene brukt i systemet blir beskrevet i denne seksjonen.

\subsection{Perl}
Perl er et dynamisk programmeringsspråk laget først og fremst for rask tekstmanipulasjon. Det har blitt inspirert av språk som C, AWK og Lisp, og er i disse dager brukt til en bred mengde arbeidsoppgaver - for eksempel nettverksprogrammering, brukergrensesnitt, webgrensesnitt og mer. Perl har mange innebygde moduler som man kan dra nytte av, og CPAN (Comprehensive Perl Archive Network) tilbyr mange tredjeparts moduler, som kan forbedre og forenkle forskjellige oppgaver.

\subsection{CGI}
Common Gateway Interface (CGI) er en standard for å gi et grensesnitt mellom en ekstern applikasjon og en informasjonsserver (for eksempel en HTTP-server). Et CGI-program blir eksekvert i samtid, noe som gir muligheten til å vise dynamisk informasjon.

Ved å dra nytte av den innebygde CGI-modulen til Perl, gir det muligheten til å lage og vise dynamiske websider.

\subsection{HTML}
HyperText Markup Language (HTML) er brukt til å publisere dokumenter på web, og er sammensatt av kode og tagger som en nettleser tolker.

\subsection{VRML}
Virtual Reality Modelling Language (VRML) er et språk hvor man definerer scener, som gir en bruker muligheten til å bevege seg rundt i et tredimensjonalt miljø. VRML er mye brukt til å legge til tredimensjonale effekter på en webside. 

\subsection{MySQL}
MySQL (My Structured Query Language) er en databasemotor som sitter som et lag oppe på en SQL (Structured Query Language) database. MySQL brukes til å gi et grensesnitt mellom bruker og database, hvor man kan aksessere, endre og prosessere data i en database.

Perl har en innebygd modul kalt DBI (database interface) som kan tolke flere typer databasespråk, og det kan bruke MySQL til å kjøre spørringer og transaksjoner mot en database.

\subsection{Apache}
Apache er en web server som kan bli konfigurert til å kjøre CGI-programmer og MySQL.

\section{Sentrale datastrukturer}

\subsection{Database}


%I vårt program har også ukjente verdier i databasen en betydning for oss.
\section{Oppbygning av programmet}

XML-filene inneholder mye konfigurasjonsinformasjon, og det er ikke alle komponentene man ønsker å visualisere. I data import delen av programmet, blir det valgt ut ønskede komponenter til visualisering. De foretrukne komponentene blir lagt inn i en database, og er ved hjelp dataimportereren ferdigstilt til å bli grafisk fremstilt.

\subsection{DataImporter}

Den lokale konfigurasjonsfilen inneholder de komponenter som skal bli ekstrahert fra XML-filene og bli lagt til i databasen, og namespace som tilhører dem. 

Vår importer henter først ut all informasjon fra konfigurasjonsfilen, og redegjør hva som skal bli tabeller og kolonnenavn i databasen. Den sjekker i mot databasen om tabellene eksisterer fra før av, og gjør eventuelle endringer hvis databasen ikke samsvarer med gjeldende konfigurasjon. Importeren bruker LibXML modulen til å tolke profilfilene. I hver eneste fil er det en obligatorisk komponent som kalles `last\_modified' hvor datoen for siste endring fra LCFG-server er blitt gjort. Denne datoen blir hentet opp av scriptet, og går til neste fil hvis maskin og dato allerede er lagt inn i database. Selvom det er ny dato `last\_modified' i forhold til databasen, trenger vi å forsikre oss om at vi ikke legger inn redundant data. Derfor sjekker scriptet om de nye verdiene allerede ligger der, og legger de til hvis det er nye verdier.

\subsection{DataVisualizer}

\subsubsection{VRML\_Generator}
VRML\_Generator er den største klassen i vårt system, og brukes av alle Visualiseringsmoduler. Klassens hovedoppgave er å generere gyldig VRML-kode basert på attributter og metoder som kalles av Visualiseringsmodulene.
Klassen er delt opp i følgende deler:

\paragraph{Utility methods}
Dette er metoder som kan brukes av enhver visualiseringsteknikk. Typiske funksjoner inkluderer generering av ulike farger og posisjoner, samt konvertering av tekststrenger til gyldig VRML-syntaks.
  
\paragraph{General VRML methods}
Disse metodene er også felles, generiske metoder som returnerer vanlige VRML-noder, blant annet Timer, Transform, Group, Interpolator og Text. 

\paragraph{Proto methods}
Proto-metodene genererer statiske strenger som danner VRML Proto-noder.
Proto-noder er definisjoner som består av en eller flere VRML-noder, felter og Scripts. 
Disse brukes i visualiseringene til å definere utseende og oppførsel til blant annet maskin-noder, viewpoints og menyer.
For en mer utdypende forklaring av VRML-noder og syntax, referer til VRML97 Spec, kilde....

\paragraph{Specific methods for each Visualisation technique}
Denne biten er videre delt opp i en del for hver spesielle teknikk.
Her legges spesifikke metodekall som kun brukes av en enkelt visualisering. 

\section{Visualiseringsproduktene}
Felles for alle visualiseringsteknikkene, er at de tar imot et eller flere felter fra databasen, og danner grupper basert på de forskjellige verdiene som feltene kan ha. En visualisering dannes av ett eller flere slike kriterier, og de ulike teknikkene utformer gruppene visuelt.

\subsection{GroupVisualizer.pm}
\begin{verbatim}
Avhengigheter:

VRML_Generator.pm
DAL.pm

Konstruktør: new()
Antall parametere: 4 påkrevde 
( string tabell, string felt, string tabell2, string felt2) 
+ 3 valgfrie (string tabell3, string felt3, string verdi3)
\end{verbatim}

Denne klassen lager en visualisering der alle maskinene først blir fargekodet basert på kriterium 1 og plassert rundt en tilhørende grupperingsnode basert på kriterium 2. I tillegg kan man velge å sette et tredje kriterium som blir markert ved at noden er snudd 45 grader og roterer rundt y-aksen. Ved opprettelse av GroupVisualizer-objekter med metoden new() kreves fire parametere som angir tabell og felt for henholdsvis kriterium 1 og 2. Hvis man vil sette det tredje kriteriet, kan man sende med ytterligere tre parametere for å angi tabell, felt og verdi for dette.

\subsubsection{Viktige metodekall}
\paragraph{generateWorld()} er den hovedmetoden som står for selve visualiseringen. Først henter metoden de nødvendige dataene via DAL.pm, for deretter å generere vrml-filen ved hjelp av metodene makeDefNodes() og makeNodes() i tillegg til klassen VRML\_Generator.

\paragraph{makeDefNodes()} genererer et sett med definisjonsnoder der hver distinkte verdi av kriterium 1 representeres av en farge. Disse nodene brukes som grunnlag for menyen og for farge på hver maskin.

\paragraph{makeNodes()} genererer vrmlkode for alle maskinene. Maskinene blir plassert  i grupper basert på kriterium 2 og definisjonsnodene som ble laget av makeDefNodes() brukes som grunnlag for fargen.  


\subsection{PyramidVisualizer.pm}
\begin{verbatim}
Avhengigheter:

VRML_Generator.pm
DAL.pm

Konstruktør: new()
Antall parametere: 6 ( string tabell, string felt, string verdi,
string tabell2, string felt2, string verdi2)

Viktige metodekall:
generateWorld() -- returnerer visualiseringen
\end{verbatim}
Denne klassen visualiserer grupper i form av en pyramide med tre trinn. Det nederste trinnet representerer alle maskiner som finnes i databasen. Trinnet i midten representerer alle maskiner som oppfyller et gitt kriterium, og det øverste representerer maskinene som både oppfyller kriteriet fra trinn to, samt nok et kriterium. De tre første parametrene som kreves ved opprettelse av et PyramidVisualizer-objekt med metoden new() representerer tabell, felt og verdi i databasen for det første kriteriet som skal tilfredsstilles, mens de tre siste representerer de tilsvarende verdiene for det andre kriteriet. Selve pyramiden genereres fra metoden generateWorld() som først henter ut data fra databasen via modulen DAL.pm, for så å beregne størrelsen på hvert trinn og lage vrml-koden ved hjelp av modulen VRML\_Generator.pm.
%Resultatet vises i figur **sett inn fint bilde her**.


\subsection{Nodevisualizer.pm}
\begin{verbatim}
Avhengigheter:

VRML_Generator.pm
DAL.pm

Konstruktør: new()
Antall parametre: 3 (string maskinnavn1, string maskinnavn2, Date dato)
\end{verbatim}
Denne klassen lager en visualisering som sammenligner komponentinformasjonen til to maskiner. De to maskinene i parameterlista er angitt som noder i visualiseringen, og peker på tilhørende komponenter. De tilhørende tabellene til komponentene utgjør et gitter, og komponentene er gruppert under disse. 

Klassen henter nodeinformasjon om hver av maskinene fra DAL, og slår disse sammen til én datastruktur. Blir det ikke angitt dato, hentes nyeste informasjon fra hver av maskinene.  

\subsubsection{Viktige metodekall}
\paragraph{generateWorld()} er hovedmetoden for selve visualiseringen. Den genererer VRML-kode ved hjelp av de lokale metodene makeDefNodes() og makeNodes() og henter ut generell VRML-kode fra VRML\_Generatoren, og returnerer denne koden i form av en strengvariabel.

\paragraph{makeDefNodes()} genererer et sett med definisjonsnoder ut i fra tre forskjellige fargedistinksjoner; én for komponentene til første maskin, én for komponentene til andre maskin og én for komponenter som har like konfigurasjon. Disse nodene vil brukes som grunnlag for menyen og for komponentnoder som vil tilhøre de tre fargene. 

\paragraph{makeNodes()} genererer alle komponenter tilhørende noder i gitteret og linjene som skal bli trukket fra maskin til komponent. Komponentene blir plassert i grupper basert på hvilke tabeller de er hentet fra, og får farge etter hvilken maskin de tilhører. 
\begin{figure}[ht]
\centering
\includegraphics[scale=0.3]{nodevisuallcompsainjarvi.PNG} 
\caption{Nodevisualisering alle komponenter mellom to maskiner} \label{Nodevisualisering1}
\end{figure}


\begin{figure}[ht]
\centering
\includegraphics[scale=0.3]{nodevisudiffcompsainjarvi.PNG} 
\caption{Nodevisualisering forskjellige komponenter mellom to maskiner} \label{Nodevisualisering2}
\end{figure}




\subsection{SpiralVisualizer.pm}

\begin{verbatim}
Avhengigheter:

VRML_Generator.pm
DAL.pm

Konstruktør: new()
Antall parametere: 2 ( string tabell, string felt)
Viktige metodekall:
generateWorld() -- returnerer visualiseringen

Spesielle variable: 
$changeFactor (int)

\end{verbatim}
Denne klassen tar imot et kriterie og genererer en sfære per unike verdi, der sfærens radius bestemmes av antallet maskiner med sammenfallende verdier.
Sfærene plasseres i en spiralform etter størrelse, hvor de største gruppene utgjør sentrum av spiralen.
Dersom det er flere datasett tilgjengelig i databasen, og en økning eller minking av antall enkeltnoder i en gruppe forekommer, vil det animeres en skalering av sfærens radius i henholdsvis positiv eller negativ retning, sortert på dato fra eldste til nyeste konfigurasjon.
I tillegg vil også sfærenes farge endres, dersom det forekommer andre forandringer i konfigurasjonen til nodene som tilhører en gruppe.
Fargeendringen baserer seg på forholdet mellom antall oppdateringer delt på totalt antall maskiner i en gruppe, og det er mulig å endre hvor stort utslaget skal være i farge, ved å endre variabelen \$changeFactor.

Resultatet vises i figur **sett inn fint bilde her**.

\section{DAL.pm}

\begin{verbatim}
Avhengigheter:

DBI 

Konstruktør: new()
Antall parametere: 0
Viktige metodekall:
--??? 
Spesielle variable: 
-pathTilConfigFil...

\end{verbatim}





Det meste under denne linjen, skal enten oversettes eller strykes:\\


The program is divided into two separate parts:
dataImporter and dataVisualizer (figure ..) image

1. dataImporter
This is the part used to parse the XML-profiles, extract the wanted information and export it to a mySQL database. 

2. dataVisualizer
This part connects to the database and generates a visualisation based on which criterias and techiques the user sets.

\chapter{User guide}
User guide will be added here...

\section{Installing lcfgVisualizer}
installation guide.. 
\section{Importing XML data}
\paragraph{Prerequisites:}
Before extracting data into the database, some things should be prepared in a proper way:
The \textbf{name} of the XML file in conjunction with the \textbf{lcfg/last\_modified} field will be used as primary keys in the database.

The XML-files you want to import should each lie in a separate directory for each of the dates.

A database server should be up and running, preferrably a mySQL database.
Create an empty table to hold imported data.
Make sure the system requirements are met (see SRS section further down)

Edit the config file cfg/vcsd.cfg to fit your system and needs.
In specific, make sure the database section matches your database server and tablename.
For further info about vcsd.cfg, see section \ref{configfile} .

\subsection{Initial import}
When the config file is fully configured, and all the desired components have been declared, the extracting of data into the database can begin. Run the perl file XML\_to\_DB.pl in a terminal or on a commmand line. If everything is configured correctly, this should go smoothly. For each main component (e.g. $<$inv$>$ ) this operation takes approximately one minute on a system with 1000 XML files, depending on the Hardware and LAN/Internet speed if the database is externally located.

The script will print out the parameters and child values chosen, confirm by pressing enter for each main component.
The script will print out the number of files found in the folder, push any key to continue the import.
If some XML-files is not well-formed or have errors, the script will print a warning and the file will not be imported.
When done, the script will print out the number of errors encountered ( if any ) and the time elapsed.
You have now imported a dataset, and may go on to adding further data sets \ref{append}, or skipping to the visualisation part \ref{visualisation}.

\subsection{Appending newer data sets}
\label{append}
To append more datasets to the database, just edit vcsd.cfg and set the xmlpath-variable to reflect the folder you want to import.
It is wise (but not necessary) to keep all the components that were used in an initial import.
If you add further components that were not imported initally, the initial values will be set to 'unknown'. %skrive litt smartere om dette.. 
Be also aware of the following: If you try to import a dataset which is older than the newest dataset imported, no values will be imported!
So make sure you import all datasets in the right order, going from oldest to newest.
\section{The config file (vcsd.cfg) }
\label{configfile}
% her er noe som kanskje skal inn også 
%\subsection{XML\_to\_DB}
%The config file (vcsd.cfg) in /cfg is used to define the different filepaths and components which are going to be extracted to the database. The databaseinformation, namespace of XML-files, filepath of XML-files, and at least one component needs to be declared before using the XML to DB script. The one mandatory component in vcsd.cfg is an arbitrary child component from components/profile.
The config file can be edited with any editor.
Lines beginning with a \# is ignored.
Consists of the following parts: 
\paragraph{DatabaseInfo}
Set the connection info to fit your mysql server.

\paragraph{PathToFiles}
This path should reflect the path to the dataset you want to import, 
for instance 
xmlpath=/home/user/xml-profiles/2008-03-05

\paragraph{Namespace}
Used by libXML to parse the data files. Default value is:
\\
namespace=http://www.lcfg.org/namespace/profile-1.0

\paragraph{Component}
This is the section where you specify which fields to import into the database.
The format is :\\ 
comp1 = inv/os\\ 

\paragraph{PreferredFields}
This section specifies which imported fields to use as a \"machine description\" in some visualisation techniques. Choose some values from the components section you configured. 

A sample configuration file cfg/vcsd.cfg is shown here:

\begin{verbatim}
#! VCSD Configuration file
# Configure with care
# This is just a sample file

<DatabaseInfo>
db=lcfg
dbtype=mySQL
dbhost=localhost
dbuser=username
dbpass=password
dbport=3306
</DatabaseInfo>

<PathToFiles>
#Uncomment one of these variables below

xmlpath=E:\mydocs\profiles\profiles-2008-03-05

</PathToFiles>

<Namespace>
namespace=http://www.lcfg.org/namespace/profile-1.0
</Namespace>

<Component>
#Which components to import from the XML files
#These components must be written like: comp<number>=comp/childcomp
# where <number> is an unique integer (doesn't need to be in order)
# and comp/childcomp is an XPath expression.  
#one profile component (such as profile/domain) is mandatory

comp1=inv/domain
comp2=inv/location
comp3=inv/manager
comp4=inv/model
comp5=inv/os
comp6=inv/owner
comp7=inv/sno
comp8=network/extrahosts
comp9=network/gateway
comp10=network/gatewaydev
comp17=xinetd/enableservices
comp22=profile/domain  #MANDATORY!
</Component>

<PreferredFields>
#The fields used to display information about one specific node.
# These fields will be collected out of the database generated, not the xml-files
# Hence it is important that these values also exist in the components section
prefield1=inv/manager
prefield2=inv/owner
prefield3=inv/location
prefield4=inv/sno
prefield5=inv/model
prefield6=inv/os
prefield7=network/gateway
#prefield8=profile/group
</PreferredFields>

\end{verbatim}


\section{Visualizing data}
\label{visualisation}
Here is something on how to visualize..

Prerequisites: A modern Web browser, octaga player. 
Fire up your browser and point it to http://localhost/cgi-bin/index.cgi

From the menu, choose a visualisation technique.
Depending on the technique chosen, choose the desired number of parameters and the desired fields to cluster on.
The visualisation will be embedded in the browser window, or you can open it manually from the output folder specified in vscd.cfg.

About navigation in the vrml browser... \\
This is how you do it.. \\ For further reference, please see www.octaga.no 


About the different techniques...\\

\chapter{System reference}

\section*{}
This part of the document will contain  documentation needed by developers for maintanence and expansion of the system

\newpage


\section{DataVisualizer}

\subsection{GUI}
The GUI consists of the following files and classes: 
\paragraph{cgiFunctions.pm}
Methods for printing HTML elements such as forms, stylesheets, menu, javascripts and embed visualisations.
Dependencies: DAL.pm

\paragraph{cgi scripts}
Index.cgi -- Start page \\
nodeVisualisation.cgi \\
pyramidVisualisation.cgi\\
groupVisualisation.cgi\\
spiralVisualisation.cgi\\
Dependencies: CGI

\subsection{BLL}
The business layer.
\subsubsection{Visualisation Library}
 Consists of a library of Visualisation modules, namely:
\subsubsection{GroupVisualizer}

\subsubsection{PyramidVisualizer}

\subsection{SpiralVisualizer}

\subsection{NodeVisualizer}

\subsection{PyramidVisualizer}
This module generates the vrml for the pyramid visualization. 
The pyramid visualizer module depends on the following modules: 

\subsubsection{Method descriptions}

\paragraph{new()}
This method is a constructor generating a new PyramidVisualizer object. Six parameters are required. 
The first three represent the table name, field name and field value for the first criteria query, while the last three represent the same values for the second criteria.

\paragraph{generateWorld()}
This method is responsible for generating the VRML-file for the visualization. 
\begin{itemize}
\item[-]Parameters: none
\item[-]Return value: String
\end{itemize}
First the data is retrieved from DAL, then the size of the steps are calculated before the string for the vrml file is bulit and returned.

\paragraph{hashValueAscendingNum}
Helping method, sorts a hash by its values in ascending order. Uses the global hash \verb"%steps"


\paragraph{hashValueDescendingNum}
Helping method, sorts a hash by its values in descending order. Uses the global hash \verb"%steps"


The visualizer modules depend on the following modules: 
\begin{itemize}
\item[-]
DAL.pm
\item[-]
vrmlGenerator.pm
\end{itemize}

\subsection{VRML\_Generator}

The VRML\_Generator is the largest module and is used by all the visualisation modules. Its main task is to generate valid VRML strings based on the attributes and method calls in the visualisation modules.
It is divided into different parts: 
\paragraph{Utility methods} 
These are methods which can be used by any visualisation, such as setting color values, generating vector positions, printing routes and converting strings to "VRML-safe" syntax.

\paragraph{General VRML methods}
These methods are also generic methods which generates valid VRML code from desired parameters. 
A lot of common VRML nodes can be generated, including Timer, Transform, Group, Interpolator and Text. 
 
\paragraph{Proto methods}
Generates valid Proto nodes. (Static strings).
Proto nodes are definitions built by VRML nodes, fields and Scripts.
Used to define MachineNodes, viewpoints and menuitems and their attributes.

\paragraph{Specific methods for each Visualisation technique}
Methods used only by one specific visualisation module.

\subsection{DAL}
The Data Access Layer. \\
Files: DAL.pm \\
Connects to the database. \\
Dependencies: DBI\\

\section*{SRS System Requirement Specification}

\section*{Structure}
	Bilde / visualisering av komponenter og underprogrammer 
	\subsection*{Hardware requirements}
	
	Any newer computer (X86-compatible).

	\subsection*{Software requirements}

	
	Perl \verb#>=# 5.10 with XML::LibXML::XPathContext;
	For windows, the following packages are required to 		parse the XML files:
	\begin{itemize}
		\item[-]
		XML::LibXML
		\item[-]
		XML-LibXML-Common
		\item[-]
		XML-NamespaceSupport
		\item[-]
		XML::SAX 
	\end{itemize}	
	These packages can be retrieved from 
\verb"http://cpan.uwinnipeg.ca/PPMPackages/10xx/"	

	mySQL \verb#>=# 5.0.45
	apache webserver
	
	The client:
	A modern web browser -- tested in IE6, Mozilla Firefox, Opera, Safari .. bla
	VRML browser: recommended Octaga Player 
	
	
	

\section*{Database}

\section{Technologies}
This section will describe the technologies used throughout the project period to accomplish the final product.

\subsection{Perl}
Perl is dynamic programming language originally developed for fast text manipulation. It has been influenced by languages like C, AWK, and Lisp, and nowadays used for a wide range of tasks - e.g. network programming, GUI and web-programming, etc. Many operating systems are supported by Perl. The CPAN (Comprehensive Perl Archive Network) provides many third-party modules, which can improve and simplify various tasks.

\subsection{CGI}
The Common Gateway Interface (CGI) is a standard for interfacing external applications with an information server, e.g. HTTP servers. A CGI program is exectuted in real-time, giving the ability to display dynamic information.

Perl has CGI as a built-in module, and can use it to dynamically create web pages. 

\subsection{HTML}
The HyperText Markup Language (HTML) is used when publishing documents on the world wide web, and consists of codes which a browser interprets.

\subsection{VRML}
The Virtual Reality Modelling Language (VRML) is used to define three dimensional scenes, which allows a user to move around within its environment. VRML programs are event driven like HTML, and is commonly used to embed 3D effects on a web page. 

\subsection{MySQL}
The Structured Query Language (SQL) is a language that provides an interface to a database. MySQL is an open source software relational database management system, which is used to handle querys and transactions to a database.

Perl has a built-in module called DBI (database interface) which can interpret many types of structured query languages and

\subsection{Apache}
Apache is a web server which can be configured to run Perl::CGI and MySQL.


\section*{Installation}
Installation on Windows:

You need to install the following third-party software:

Apache, Perl, mySQL

We recommend installing activestate Perl -- link ,..

Install it to a folder, we will use \verb"C:\perl"

And then install WAMP server  -- -link

Unzip lcfgVisualizer.zip to a desired path, in our example we will use
\verb"C:/lcfgVisualiser/"

go to the folder and edit the .cgi files --- change the first line to reflect the location of your perl.exe file.

In this example, we will use \verb "#!C:\perl\bin\perl.exe -w"

To open for cgi execution in apache, you need the following lines in 
httpd.conf:

In the loadModule section, make sure these lines are not commented:
\begin{verbatim}
LoadModule alias_module modules/mod_alias.so
LoadModule cgi_module modules/mod_cgi.so
\end{verbatim}
in the section \verb"<IfModule alias_module>", add the following lines:
\begin{verbatim}
ScriptAlias /cgi-bin/ "C:/lcfgVisualizer/cgi/"

<Directory "C:/lcfgVisualizer/cgi/">
    AllowOverride None
    Options +ExecCGI Indexes
    Order allow,deny
    Allow from all
	AddHandler cgi-script .cgi .pl
</Directory>
\end{verbatim}

In the root directory of your apache server root ( default .... ), 
make a new folder named output
% vil ikke perl opprette katalogen for oss?
% i linux blir det kanskje et problem med rettigheter på katalog og filer
in cgifunctions.pm
set 
\begin{verbatim}
\$FILEPATH = "E:\\www\\output\\";
\end{verbatim}


\section*{Bugs \& known issues}
BUG: Web browser freezes / crashes
GUI: On some systems, the octaga web browser plugin does not work.
Web browser: Internet Explorer 7.0.5730.11

Solution: Change browser -- use firefox.
Platform: 
Systems running Windows XP SP2, Internet Explorer 7.0.5730.11, Octaga player 2.2.0.12

Issue: Embedded vrml player spiser cpu, har 100 prosent i cpu.
Er dette pga skjermkortdriver feks?


Error hos meg: Embedded VRML worlds does not show up in firefox
Solved --- feil i stien til embeddinga, må ta med .. foran  \$vrmlFile


BUG: Embedded VRML is not updated 
Firefox bruker cache selv om den ikke skal  det, funker ikke å force reload.
Må restarte browser for å få vist en ny visualisering.
Foreløpig løsning: ikke printe ut embeddinga, bare link,
dette hjelper også mot at internet explorer henger hvis man prøver det i IE.


BUG: Some links inside the VRML world does not work
All links point to the same viewpoint. This is a anchor issue with name conventions.. 
- Viewer: Cortona 3D viewer
Platform: All
-Visualisations affected: groupVisualizer,...

Issue: touchSensor is misplaced in VRML Player on Mac OSX.
This means that if an object is linked with a touch sensor, one must click underneath the object to activate the sensor, rather than clicking the actual object. 

Issue: DataImporter. 
If you try to import a dataset of XML files which is older than the currently newest, nothing will be imported. 
Solution: Make sure you import datasets in a correct order, from oldest to latest.

BUG: Empty fields from the database in the CGI
When trying to visualize a field which has no values at all from the database, the user interface does not give any warnings about it. The select box in the web page is empty, and it is impossible to draw a VRML file.
Solution: Go back a few steps in the web page, and select another table.


%Noe av dette kommer et eller annet sted...
\subsubsection{Hendelsesflyt for import til DB}
\begin{itemize}
\item 
Leser inn cfg fil
\item 
cfg-fila skal inneholde:
\begin{itemize}
\item 
Databaseinformasjon (username, pass, host, port, type of base)
\item 
Tabell- og kolonnenavn (inv / os) - attributt
\item 
Namespace over xml-filene
\item 
Path til zip-fil over profiler
\end{itemize}
\item 
 Tester databasetilkobling med parametre fra cfg
\item 
 Zipper opp profiler og legger de i en temporær katalog
\item 
 Deklarer en array over tabell (hovedkomponenter - eksempel inv)
 Og i denne arrayen må det legges flere nye hasher over kolonnenavn (eksempel inv/os)
\item 
Deklarer også en boolsk array over tabellene, som senere vil si i fra om operasjonenene har gått bra eller ikke
Hvis det er noen som ikke har gått OK, så kopiereres ikke tabellene tilbake.
\item 
Opprett tabeller med kolonnenavn hentet fra cfg Hvis tabell eksisterer fra før av og kolonnenavnene ikke samsvarer:
Kopier tabell og alter.
Denne nye tabellen skal det legges data i, og senere skal den overskrive den gamle
Hvis tabell eksisterer fra før av og kolonnenavnene samsvarer:
\item 
Append table.
\item 
Løpe i gjennom filer ( foreach <>)
     Deklarer man rotnode, etc
\item 
Finne  "last\_modified"  og legge den i en variabel sub getLastModified(maskinnavn)
\item 
Hvis  last\_modified  fra xml er nyere enn den i DB, fortsett
\item 
Opprett en boolsk variabel som skal holde rede på om det blir gjort noen forandringer, \$changed
\item    
Løpe i gjennom tabellparametre (hovedkomponenter)
\item 
Sjekke om parameteren eksisterer i xml-filen
Bør sjekke nivået på parameteren som kommer inn, og at det i hele tatt er verdi der.
\item 
Finne ut verdien til parameteren, og legger denne som en value til tilhørende key i hash (f.eks. "fc6" til inv/os) Ikke glem attributten hvis vi skal ha den.
\end{itemize}
Hvis databasen allerede eksisterte, må vi selecte fra databasen alle dataene fra den maskinen vi holder på med og sjekke mot hashen om det er noen nye verdier. Hvis det er det, så må vi inserte en ny rad og gi \$changed verdien "true".

\begin{itemize}
\item    
Sjekke \$changed
\item  
Hvis "true", oppdatere tabell  last\_modified med last\_modified 
\item  
Sjekke om det er noen false-verdier i den boolske arrayen
\item  
Overskrive de gamle tabellene hvis alle er OK.
\\
%\begin{verbatim}
%sub getLastModified
%{
%    my \$tempMachine = shift  ;
%   
%     Hente ut fra DAL last modified fra 			 denne maskinen
%     Returnere denne
%}
%\end{verbatim}
\end{itemize}
TODO:
Lag en tabell  last\_modified , som inneholder id, maskinnnavn og lastmodified
Denne må oppdateres hver gang det blir gjort en endring

Logge alle aktiviteter/forandringer som skjer ved hjelp av dette scriptet
 For eksempel, antall rader forandret, mange filer som var helt like, etc etc


\end{document}