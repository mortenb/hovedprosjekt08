\documentclass[12pt,norsk,a4paper,onecolumn]{article}
\usepackage[latin1]{inputenc}
\usepackage{babel}
\usepackage{verbatim}
\usepackage{alltt}
\usepackage{graphicx}

% to reduce indent
%\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}
% Declare document specific definitions
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\tolerance = 5000
\hbadness = \tolerance
\pretolerance = 2000

\title{Produktdokumentasjon}
\date{23 Mai 2008}
\author{Lars Martin Bredal \and Morten Byhring \and Tom Erik Iversen
\and Høgskolen i Oslo, avdeling for ingeniørutdanning
\and Gruppe 08-01}

\begin{document}
\maketitle
%\setcounter{page}{10}
\newpage
\setlength{\parskip}{0ex}

\tableofcontents
\listoffigures
%\setlength{\parskip}{2ex plus 0.5ex minus 0.2ex}\newpage
\newpage
\section{Innledning}
Dette dokument forklarer og beskriver produktet laget av gruppe 08-01.
Det beskriver teknologier brukt og oppbygning av systemet.
Dokumentet er laget med hensyns på veileder og sensor.
Det kreves noe forkunnskap om informasjonsteknologi for å forstå helheten av dette dokumentet. Teksten er uthevet når det skrives om spesifikke deler av programmet, for å gjøre det lettere å skille mellom kode og tekst.

Produktdokumentasjon er optimalisert for papirutskrift.

\section{Beskrivelse av programmet}
VSCD sitt bruksområde er ekstrahering av data og visualisering av konfigurasjons(u)likhet.  Konfigurasjonsinnstillingene kommer fra en ekstern LCFG-server (Local ConFiGuration system). LCFG er et system for automatisk installering og administrering av konfigurasjonen for et stort antall maskiner. Filene distribuert av LCFG blir tolket av VSCD, og konfigurasjon som egner seg til visualisering blir lagret i intern database. Disse dataene blir brukt av VSCD sin visualiseringsmaskin til å produsere tredimensjonale scenarier.

\section{Verktøy}
Ved valg av verktøy er det flere faktorer som gjenspeiler valgene. Programmet skal være kompatibelt på flere typer systemer, og derfor har plattformuavhengige verktøy vært viktig. Til utvikling av systemet har vi valgt Perl som programmeringsspråk, på grunn av sin gode evne til å manipulere tekst. Visualisering av konfigurasjon vil bli gjort i form av VRML, for å bygge tredimensjonale scenarier. Til lagring av data brukes (My)SQL, fordi Perl tilbyr grensesnitt mellom script og database. Som grensesnitt vil VRML-filene fungere selv, men vi har også en web-løsning hvor HTML er brukt for å gi mer brukervennlig interaksjon med programmet for brukeren. Under er teknologiene beskrevet i mer detalj.

\begin{description}

\item[Perl] er et dynamisk programmeringsspråk laget først og fremst for rask tekstmanipulasjon. Det har blitt inspirert av språk som C, AWK og Lisp, og er i disse dager brukt til en bred mengde arbeidsoppgaver - for eksempel nettverksprogrammering, brukergrensesnitt, webgrensesnitt og mer. Perl har mange innebygde moduler som man kan dra nytte av, og CPAN (Comprehensive Perl Archive Network) tilbyr mange tredjeparts moduler, som kan forbedre og forenkle forskjellige oppgaver. Produktet er optimalisert for bruk av Perl 5.10.x.

\item[Virtual Reality Modelling Language]
VRML er et modelleringsspråk, designet for å tilby et mer brukervennlig miljø å lage digitale tredimensjonale scenarier i. Det innlemmer 3-D figurer, farger, teksturer og lyder for en virtuell verden som en bruker kan bevege seg rundt i. Språket blir skrevet i tekstform, og blir tolket av en VRML-leser og vist på skjerm. Den nåværende spesifikasjonen, VRML 97, støtter integrering av flere dynamiske programmeringsspråk. Det tillater den virtuelle verden å være dynamisk, i konstant bevegelse.

\item[HyperText Markup Language]
HTML er et språk utviklet for å tillate oppretting av websider. \verb"HyperText" betyr at en bruker kan flytte seg rundt i internett på en ikke-lineær måte, ved klikk på en \verb"hyperlink" kan man gå hvor man vil. \verb"Markup" er hva HTML-taggene skal gjøre med teksten i dokumentet. HTML er relativt lett å lære, og er et ganske kraftig verktøy i hva det tillater å lage. Det er konstant under revisjon og utvikling for å møte kravene som blir stilt i og med at språket er standard for de fleste nettlesere.

\item[Common Gateway Interface]
CGI er en standard for å gi et grensesnitt mellom en ekstern applikasjon og en informasjonsserver (for eksempel en web-server). Et CGI-program blir eksekvert i samtid, noe som gir muligheten til å vise dynamisk informasjon.Ved å dra nytte av den innebygde CGI-modulen til Perl, gir det muligheten til å lage og vise dynamiske websider.

\item[My Structured Query Language] MySQL er en databasemotor som sitter som et lag oppe på en SQL (Structured Query Language) database. MySQL brukes til å gi et grensesnitt mellom bruker og database, hvor man kan aksessere, endre og prosessere data i en database.

Perl har en innebygd modul kalt DBI (database interface) som kan tolke flere typer databasespråk, og det kan bruke MySQL til å kjøre spørringer og transaksjoner mot en database.

\item[Apache] er en web server som kan bli konfigurert til å kjøre eksterne programmer gjennom CGI og MySQL.

\end{description}



%I vårt program har også ukjente verdier i databasen en betydning for oss.
\section{Oppbygning av programmet}
Programmet har blitt delt opp i en hierarkisk lagstruktur, som hver har sitt ansvars- og bruksområde; dataaksess, visualisering og presentasjon. Det finnes også en importeringsdel for å tolke konfigurasjonsfilene distribuert av ekstern server.

\begin{description}

\item[Importeringsdelen] har ansvaret for å sortere ut ønsket informasjon fra XML-filer, og legge dette inn i en intern database. Dataimportereren henter parametre fra en sentral konfigurasjonsfil, og setter opp ønsket datastruktur ut i fra disse. XML-filene blir tolket, verdier blir ekstrahert og sendt videre til DAL (dataaksesslag) for å bli lagret.

\item[Dataaksesslaget] (DAL) har ansvaret for å gjøre spørringer mot database, og returnere spørringsresultatene i hensiktsmessige datastrukturer.

\item[Forretningslogikklaget] (BLL) har ansvaret for å grafisk fremstille konfigurasjonsinnstillinger fra XML-filene. Tar i mot kriterier, henter relevant informasjon gjennom DAL, og genererer VRML-kode.

\item[Presentasjonslaget] tilbyr brukergrensesnittet (GUI). Det er to typer brukergrensesnitt i VSCD. Verdener generert kan sees rett i en VRML-leser, og kan også bli lagt til som tilleggsfunksjonalitet i vår web-løsning. 
\end{description}

\subsection{Importering}

Den lokale konfigurasjonsfilen inneholder de komponenter som skal bli ekstrahert fra XML-filene og bli lagt til i databasen, og namespace som tilhører dem. 

Importereren henter først ut all informasjon fra konfigurasjonsfilen, og redegjør hva som skal bli tabeller og kolonnenavn i databasen. Den sjekker databasen om tabellene eksisterer fra før av, og gjør eventuelle endringer hvis databasen ikke samsvarer med gjeldende konfigurasjon. Den bruker \verb"Perl::LibXML" modulen til å tolke profilfilene. I hver eneste fil er det en obligatorisk komponent som kalles \verb"<last_modified>" hvor datoen for siste endring fra LCFG-server er blitt gjort. Denne datoen blir hentet opp av scriptet, og går til neste fil hvis maskin og dato allerede er lagt inn i database. Selvom det er ny dato i forhold til databasen, trenger vi å forsikre oss om at vi ikke legger inn redundant data. Derfor sjekker scriptet om de nye verdiene allerede ligger der, og legger de til hvis det er nye verdier.

\subsection{DAL.pm}

DAL.pm fungerer som vårt dataaksesslag. Den har to bruksområder; hente ut informasjon fra database til visualiseringsmaskinen (BLL), og legge inn data fra \verb"XML_to_DB.pl". 

Hver gang et DAL-objekt blir opprettet, vil den opprette en hash som tilsvarer verdier skrevet i konfigurasjonsfilen. DAL bruker verdiene i denne hashen som parametre, og de blir primært brukt til å koble seg opp til databasen.

Metodene for importering og ekstrahering av verdier er generiske. Ved henting av informasjon fra databasen, trenger metodene tabellnavn som parameter. Det som i hovedgrad skiller disse metodene fra hverandre er oppbygningen til SQL-spørringene, og hvilken struktur på dataene som skal bli returnert.

\subsubsection{Viktige metoder}

\paragraph{new()}
\begin{verbatim}
Antall parameter: Ingen

Returverdi: Referanse til instansiert objekt
\end{verbatim}
Metoden bruker først hjelpemetoder innad i klassen, for å hente parametre fra sentral konfigurasjonsfil. Der ligger blant annet tilkoblingsinformasjon til databasen. Returnerer så en referanse til seg selv som objekt.

\paragraph{getVSCDTables()}
\begin{verbatim}
Antall parameter: Ingen

Returverdi: Tabell med strenger som representerer 
			VSCD-tabellene i databasen
\end{verbatim}
Søker etter tabeller i databasen som oppfyller våres spesifikke krav til tabellstruktur (\verb"machinename" og \verb"last_modified" som primærnøkkel). Returnerer en tabell over disse. Ved import av ekstern database er denne hendig, for da kan tabellene i ny database ikke samsvare med konfigurasjonsfil, men visualisereren vil fortsatt kunne bruke databasen.

\paragraph{getNodeInformation()}
\begin{verbatim}
Antall parameter: 1(2) 
			(Streng maskinnavn, Streng dato (valgfritt))

Returverdi: Sammenfiltret hash 
			(tabellnavn => feltnavn => feltverdi)
\end{verbatim}
Henter alle nyeste verdier til en maskin i en database. Sender man med dato, vil den returnere den nyeste informasjon opp til denne datoen. Returnerer en hash over tabellnavn som peker på hasher over feltnavn som igjen peker på dems respektive verdier. \verb"getAllNodesInformation()" er en lignende metode, som returnerer informasjon om alle nodene registrert i databasen i en lignende hash-struktur.

\paragraph{getAllNodes()}
\begin{verbatim}
Antall parameter: Ingen

Returverdi: Tabell over alle maskinnavn i databasen
\end{verbatim}
Henter ut alle nodenavn som er registrert i databasen ved hjelp av \verb"profile"-tabellen. \verb"<profile>" er den eneste obligatoriske komponenten som er obligatorisk under \verb"<components>" i XML-filene. Spørringen innad i metoden ligger statisk. 

\paragraph{getNodesWithChosenCriteriaHash()}
\begin{verbatim}
Antall parameter: 3 
(Streng tabellnavn, Streng feltnavn, Streng kriterie)

Returverdi: Hash (Maskinnavn => Kriterie)
\end{verbatim}
Henter alle noder som oppfyller valgt kriterie i databasen. 

\paragraph{Spesielle variable}
\begin{verbatim}
%preferredFields - hash over ønsket visualiseringsinformasjon
$VRMLFILEPATH - filkatalogen til utskriftsfil
\end{verbatim}


\subsection{Forretningslag}

\subsubsection{VRML\_Generator}

VRML\_Generator er den største klassen i systemet, og brukes av alle visualiseringsmodulene. Klassens hovedoppgave er å generere gyldig VRML-kode basert på attributter og metoder som kalles av visualiseringsmodulene.
Klassen er delt opp i følgende seksjoner:

\paragraph{Nyttemetoder}
Dette er metoder som kan brukes av enhver visualiseringsteknikk. Typiske funksjoner inkluderer generering av ulike farger og posisjoner, samt konvertering av tekststrenger til gyldig VRML-syntaks.

\paragraph{Generelle VRML-metoder}
Disse metodene er også felles, generiske metoder som returnerer vanlige VRML-noder, blant annet \verb"Timer", \verb"Transform", \verb"Group", \verb"Interpolator" og \verb"Text". 

\paragraph{Definisjons- og protometoder}
Proto-noder er egendefinerte nodetyper som består av en eller flere VRML-noder, felter og \verb"Scripts". Først defineres nodens oppbygging, deretter kan det opprettes objekter av denne.
Disse brukes i visualiseringene til å definere utseende og oppførsel til blant annet maskin-noder, viewpoints og menyer.Det er to varianter av Proto-metodene. Den ene varianten genererer statiske strenger som  definerer VRML Proto-noder. Den andre lager en deklarasjon av et objekt av den korresponderende Proto-definisjonen. For å benytte en Proto i VRML må først definisjonsmetoden kalles en gang for å angi definisjonen, og deretter å kalles deklarsjonsmetoden for hvert objekt som skal opprettes.

For en mer utdypende forklaring av VRML-noder og syntax, referer til VRML97 Spec, kilde....

\paragraph{Konstruktør}
\subparagraph{new()}
\begin{verbatim}
Antall parameter: Ingen

Returverdi: Referanse til instansiert objekt
\end{verbatim}
Ved opprettelse av et VRML\_Generator-objekt, får eksternt skript tilgang til modulens indre metoder.

\paragraph{Generelle metoder for visualisering}
Denne seksjonen inneholder metoder som genererer noen egendefinerte VRML-noder som kan brukes av alle visualiseringene. Det er metoder for å lage grupperingsnoder, start/stopp-knapp, en kalender og maskinnoder. Den kanskje viktigste metoden i denne seksjonene genererer et skjelett for menyen som brukes av alle visualiseringsteknikkene. 

\subparagraph{vrmlHUD()}
\begin{verbatim}
Antall parameter: 4 
(Streng children, Flyttall x, Flyttall y, Flyttall z)

Returverdi: Streng av VRML-kode
\end{verbatim}
Metoden tar imot en streng som inneholder vrml-koden for alle menyelementene og tre
flyttall som angir størrelsen på en sensor som sørger for å holde menyen i riktig posisjon.
Returverdien er en ny streng som inneholder den komplette vrmlkoden for menyen.

\paragraph{Spesifikke metoder for hver visualiseringsteknikk}
Denne seksjonen er videre delt opp i en del for hver spesielle teknikk.
Her legges spesifikke metodekall som kun brukes av en enkelt visualisering. 

\subsubsection*{Gruppevisualiserer}

\subparagraph{criteria2NodesAnchorNavi()}
\begin{verbatim}
Antall parameter: Tabell av tekster

Returverdi: Streng av VRML-kode
\end{verbatim}
Denne metoden lager VRML-koden for grupperingsnodene.  Metoden bruker antallet parametere til å beregne posisjoner for nodene og oppretter en grupperingsnode for hver streng i parameterlista. For hver av disse beregnes et VRML-viewpoint for å se noden med tilhørende satellitter på nært hold. I tillegg beregnes et standard viewpoint der alle gruppene er synlige.

\subparagraph{groupVisDefNodes()}
\begin{verbatim}
Antall parameter: Hash med maskinnavn som nøkler. 

Returverdi: Streng med VRML-kode
\end{verbatim}
Denne metoden lager VRML-koden for elementene som skal settes inn i HUD-menyen i tillegg til et sett \verb"Script"-noder for å styre av visning av hver maskintype. Først lager metoden ett menyelement som brukes til å starte animasjonen av maskinene, og ett som brukes for å slå av og på visning av tredje kriterium. Deretter genereres et menyelement for hver nøkkelverdi i hashen. Disse bygges opp av nøkkelteksten og en farget boks som senere også brukes for å representere en maskin med tilsvarende verdi. Fargen på boksen løper mellom 36 forskjellige verdier fra den globale tabellen \verb"@colors", noe som betyr at dersom antallet verdier i hashen overstiger dette, vil samme farge brukes på nytt. Definisjonen av boksen som genereres vil derimot være unik slik at de tilhørende maskinene kan filtreres ut i visualiseringen.

\subsubsection*{Pyramidevisualiserer}
Det er to metoder som er spesielle for pyramidevisualiseringen. Metoden \verb"pyramidMenuItems()" lager vrmlkode for menyelementene til HUD-menyen, mens metoden \verb"pyramidStep()" lager vrml-koden for et pyramidetrinn.
\subsubsection*{Nodevisualiserer}
Her ligger metoder som bare brukes av nodevisualiseringen. Metoden \verb"defNodes()" genererer satelittnodene og menyen, og virker på samme måte som metoden for \verb"groupVisDefNodes()"  i gruppevisualisereren. Metoden \verb"vrmlStaticGridTransforms()" genererer vrmlkoden for de to nodene som skal sammenliknes og \verb"vrmlMakeILS()" lager forbindelseslinjene mellom disse og satelittnodene.

\subsubsection*{Konstruktør} %Hvor rakkern skal vi plassere konstruktøren for VRML_Generator? 
\subparagraph{new()}
\begin{verbatim}
Antall parameter: Ingen

Returverdi: Referanse til instansiert objekt.
\end{verbatim}

\subsubsection{Visualiseringsteknikkene}
Felles for alle visualiseringsteknikkene, er at de tar imot et eller flere felter fra databasen, og danner grupper basert på de forskjellige verdiene som feltene kan ha. En visualisering dannes av ett eller flere slike kriterier, og de ulike teknikkene utformer gruppene visuelt. Alle visualiseringsteknikkene avhenger av \verb"VRML\_Generator.pm" for generering av VRML-kode, og \verb"DAL.pm" for databaseinformasjon. 

\subsubsection{GroupVisualizer.pm}

Denne klassen lager en visualisering der alle maskinene først blir fargekodet basert på kriterium 1 og plassert rundt en tilhørende grupperingsnode basert på kriterium 2. I tillegg kan man velge å sette et tredje kriterium som blir markert ved at noden er snudd 45 grader og roterer rundt y-aksen. Ved opprettelse av GroupVisualizer-objekter med metoden \verb"new()" kreves fire parameter som angir tabell og felt for henholdsvis kriterium 1 og 2. Hvis man vil sette det tredje kriteriet, kan man sende med ytterligere tre parameter for å angi tabell, felt og verdi for dette.

\paragraph{Viktige metodekall}

\subparagraph{new()}
\begin{verbatim}
Antall parameter: 4 påkrevde 
( string tabell, string felt, string tabell2, string felt2) 
+ 3 valgfrie (string tabell3, string felt3, string verdi3)

Returverdi: En referanse til instansiert objekt
\end{verbatim}
Oppretter instans av GroupVisualizer.pm.

\subparagraph{generateWorld()}
\begin{verbatim}
Antall parameter: Ingen

Returverdi: Streng med VRML-kode
\end{verbatim}
er hovedmetoden som står for selve visualiseringen. Først henter metoden de nødvendige dataene via DAL.pm. Dataene for lagres i en hash for hvert kriterium. For første og andre kriterium inneholder hashen maskinnavn og verdi, mens hashen for tredje kriterium kun inneholder maskinnavnet siden verdien allerede er kjent. Deretter genereres vrml-filen ved hjelp av metodene \verb"makeDefNodes()" og \verb"makeNodes()" i tillegg til metoder i klassen VRML\_Generator.

\subparagraph{makeDefNodes()}
\begin{verbatim}
Antall parameter: Ingen

Returverdi: Streng med VRML-kode
\end{verbatim}
Genererer et sett med definisjonsnoder der hver distinkte verdi av kriterium 1 representeres av en farge. Disse nodene brukes som grunnlag for menyen og for farge på hver maskin.

\subparagraph{makeNodes()}
\begin{verbatim}
Antall parameter: Ingen

Returverdi: Streng med VRML-kode
\end{verbatim}
Genererer vrmlkode for alle maskinene. Metoden løper igjennom de tre hashene og plasserer maskinene i grupper basert på andre kriterium, mens definisjonsnodene som ble laget av \verb"makeDefNodes()" brukes som grunnlag for fargen.  Det tredje kriteriet representeres ved å sette en boolsk variabel som utløser animasjon av maskinen.


\subsubsection{PyramidVisualizer.pm}
Denne klassen visualiserer grupper i form av en pyramide med tre trinn. Det nederste trinnet representerer alle maskiner som finnes i databasen. Trinnet i midten representerer alle maskiner som oppfyller et gitt kriterium, og det øverste representerer maskinene som både oppfyller kriteriet fra trinn to, samt nok et kriterium.

\paragraph{Viktige metodekall}

\subparagraph{new()}
\begin{verbatim}
Antall parameter: 6 
(string tabell, string felt, string verdi,
string tabell2, string felt2, string verdi2)
\end{verbatim}
De tre første parametrene som kreves ved opprettelse av et PyramidVisualizer-objekt med metoden \verb"new()" representerer tabell, felt og verdi i databasen for det første kriteriet som skal tilfredsstilles, mens de tre siste representerer de tilsvarende verdiene for det andre kriteriet.

\subparagraph{generateWorld()}
\begin{verbatim}
Antall parameter: Ingen

Returverdi: Streng med VRML-kode
\end{verbatim}
Selve pyramiden genereres fra metoden \verb"generateWorld()" som først henter ut data fra databasen via modulen DAL.pm, for så å beregne størrelsen på hvert trinn og lage vrml-koden ved hjelp av modulen VRML\_Generator.pm.

%Resultatet vises i figur **sett inn fint bilde her**.


\subsubsection{Nodevisualizer.pm}
Denne klassen lager en visualisering som sammenligner komponentinformasjonen til to maskiner. De to maskinene i parameterlista er angitt som noder i visualiseringen, og peker på tilhørende komponenter. De tilhørende tabellene til komponentene utgjør et gitter, og komponentene er gruppert under disse. 

Klassen henter nodeinformasjon om hver av maskinene fra DAL, og slår disse sammen til én datastruktur. Blir det ikke angitt dato, hentes nyeste informasjon fra hver av maskinene. Hjelpemetodene innad i klassen bruker globale variable, og trenger derfor ingen parameter.

\paragraph{Viktige metodekall}

\subparagraph{new()}
\begin{verbatim}
Antall parameter: 3 
(string maskinnavn1, string maskinnavn2, Date dato)

Returverdi: Referanse til instansiert objekt
\end{verbatim}
Konstruktøren som oppretter og returnerer en referanse til objekt av Nodevisualizer.pm.

\subparagraph{generateWorld()} 
\begin{verbatim}
Antall parameter: Ingen

Returverdi: Streng med VRML-kode
\end{verbatim}
Hovedmetoden for selve visualiseringen. Den genererer VRML-kode ved hjelp av de lokale metodene \verb"makeDefNodes()" og \verb"makeNodes()" og henter ut generell VRML-kode fra VRML\_Generatoren, og returnerer denne koden i form av en strengvariabel.

\subparagraph{makeDefNodes()} 
\begin{verbatim}
Antall parameter: Ingen

Returverdi: Streng med VRML-kode
\end{verbatim}
Genererer et sett med definisjonsnoder ut i fra tre forskjellige fargedistinksjoner; én for komponentene til første maskin, én for komponentene til andre maskin og én for komponenter som har like konfigurasjon. Disse nodene vil brukes som grunnlag for menyen og for komponentnoder som vil tilhøre de tre fargene. 

\subparagraph{makeNodes()} 
\begin{verbatim}
Antall parameter: Ingen

Returverdi: Streng med VRML-kode
\end{verbatim}
Genererer alle komponenter tilhørende noder i gitteret og linjene som skal bli trukket fra maskin til komponent. Komponentene blir plassert i grupper basert på hvilke tabeller de er hentet fra, og får farge etter hvilken maskin de tilhører. 

\subsubsection{SpiralVisualizer.pm}

Denne klassen tar imot et kriterie og genererer en sfære per unike verdi, der sfærens radius bestemmes av antallet maskiner med sammenfallende verdier.
Sfærene plasseres i en spiralform etter størrelse, hvor de største gruppene utgjør sentrum av spiralen.
Dersom det er flere datasett tilgjengelig i databasen, og en økning eller minking av antall enkeltnoder i en gruppe forekommer, vil det animeres en skalering av sfærens radius i henholdsvis positiv eller negativ retning, sortert på dato fra eldste til nyeste konfigurasjon.
I tillegg vil også sfærenes farge endres, dersom det forekommer andre forandringer i konfigurasjonen til nodene som tilhører en gruppe.
Fargeendringen baserer seg på forholdet mellom antall oppdateringer delt på totalt antall maskiner i en gruppe, og det er mulig å endre hvor stort utslaget skal være i farge, ved å endre variabelen \verb"$changeFactor".

Resultatet vises i figur **sett inn fint bilde her**.

\paragraph{Viktige metodekall}

\subparagraph{new()}
\begin{verbatim}
Antall parameter: 2 
( string tabell, string felt)

Returverdi: 
\end{verbatim}
Oppretter en instans av Spiralvisualisereren, og returner en referanse til objektet. 

\subparagraph{generateWorld()}
\begin{verbatim}
Antall parametre: Ingen

Returverdi: String av VRML-kode
\end{verbatim}

\subparagraph{Spesielle variable}
\begin{verbatim}
$changeFactor (int)
\end{verbatim}

\subsection{Brukergrensesnitt}

Det er to måter å få bruker til å visualisere på; én ved å skrive perl-script som sender med kriterier til en visualiseringsteknikk, eller bruke web-grensesnittet som følger med. For hver visualiseringsteknikk i BLL, er det opprettet et Perl-skript som bruker CGI-protokollen til å dynamisk lage HTML fra BLL. Disse websidene muliggjør selektering av kriteria i form av lister. 
VRML-filen i seg selv fungerer som et brukergrensesnitt. 

\section{Sentrale datastrukturer}

\subsection{Database}
MySQL (5.0.x) tjener programmets interne database.

Datastrukturen spesifiseres ut fra konfigurasjonsfilen, hvor tabell- og feltnavn er definert. Tabellnavnet representerer komponenter fra XML-filene, og barnekomponentene utgjør kolonnenavn. Maskinnavn og `last\_modified' utgjør primærnøkkelen i disse, og de resterende feltene er barnenoder av hovedkomponentene.

\begin{figure}[!h]
\centering
\includegraphics[scale=0.4]{DBModel.PNG} 
\caption{Eksempel på tabeller} \label{eksempel}
\end{figure}



\section{Videre utvidelser}

Visualiseringsmotoren er oppbygd i moduler, og det muliggjør å lage nye visualiseringsteknikker. 

Metoden for å sikre SQL-spørringer bør bli utvidet til å sikre absolutt alle mulige tegn.

\end{document}