\documentclass[12pt,a4paper]{report}
\usepackage[latin1]{inputenc}
\usepackage[norsk]{babel}
\usepackage{verbatim}
\usepackage{alltt}
\usepackage{graphicx}

% to reduce indent
\setlength{\parindent}{0pt}
%\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}
%

\title{Produktdokumentasjon}
\begin{document}

\tableofcontents


\section*{Forord}
Her kommer forordet. Hvem er dette for osv

\chapter{Beskrivelse av programmet}
Hva det gjør?
LCFGvisualizer er et program som gjør om masse tekst til et 3d-bilde.

\section{Teknologi}
Her vil de forskjellige teknologiene som er brukt i systemet bli beskrevet.

\subsection{Perl}
Perl er et dynamisk programmeringsspråk laget først og fremst for rask tekstmanipulasjon. Det har blitt inspirert av språk som C, AWK og Lisp, og er i disse dager brukt til en bred mengde arbeidsoppgaver - for eksempel nettverksprogrammering, brukergrensesnitt, webgrensesnitt og mer. Perl har mange innebygde moduler som man kan dra nytte av, og CPAN (Comprehensive Perl Archive Network) tilbyr mange tredjeparts moduler, som kan forbedre og forenkle forskjellige oppgaver.

\subsection{CGI}
Common Gateway Interface (CGI) er en standard for å gi et grensesnitt mellom en ekstern applikasjon og en informasjonsserver (for eksempel en HTTP-server). Et CGI-program blir eksekvert i samtid, noe som gir muligheten til å vise dynamisk informasjon.

Ved å dra nytte av den innebygde CGI-modulen til Perl, gir det muligheten til å lage og vise dynamiske websider.

\subsection{HTML}
HyperText Markup Language (HTML) er brukt til å publisere dokumenter på web, og er sammensatt av kode og tagger som en nettleser tolker.

\subsection{VRML}
Virtual Reality Modelling Language (VRML) er et språk hvor man definerer scener, som gir en bruker muligheten til å bevege seg rundt i et tredimensjonalt miljø. VRML er mye brukt til å legge til tredimensjonale effekter på en webside. 

\subsection{MySQL}
MySQL (My Structured Query Language) er en databasemotor som sitter som et lag oppe på en SQL (Structured Query Language) database. MySQL brukes til å gi et grensesnitt mellom bruker og database, hvor man kan aksessere, endre og prosessere data i en database.

Perl har en innebygd modul kalt DBI (database interface) som kan tolke flere typer databasespråk, og det kan bruke MySQL til å kjøre spørringer og transaksjoner mot en database.

\subsection{Apache}
Apache er en web server som kan bli konfigurert til å kjøre CGI-programmer og MySQL på.

\section{Sentrale datastrukturer}

\subsection{Database}

\section{Oppbygning av programmet}
Består av to deler... bla

\subsection{DataImporter}

XML-filene inneholder mye konfigurasjonsinformasjon, og det er ikke alle komponentene man ønsker å visualisere. Den lokale konfigurasjonsfilen inneholder de komponenter som skal bli ekstrahert fra XML-filene og bli lagt til i databasen. Den bør også inneholde namespace over XML-filene.

Vår importer henter først ut all informasjon fra config-filen, og redegjør hva som skal bli tabeller og kolonnenavn i databasen. Den sjekker i mot databasen om tabellene eksisterer fra før av, og gjør eventuelle endringer hvis nåværende database ikke samsvarer med konfigurasjonsfilen. Importeren bruker LibXML modulen til å tolke profilfilene. I hver eneste fil er det en obligatorisk komponent som kalles `last\_modified' hvor datoen for siste endring fra server er blitt gjort. Denne datoen blir hentet opp av scriptet, og går til neste fil hvis maskin og dato allerede er lagt inn i database. Selvom det er ny dato `last\_modified' i forhold til databasen, trenger vi å forsikre oss om at vi ikke legger inn redundant data. Derfor sjekker scriptet om de nye verdiene allerede ligger der, og legger de til hvis det er nye verdier.

\subsection{DataVisualizer}

\subsubsection*{Beregning av 3D-posisjoner}
En viktig del av visualiseringen har vært å finne algoritmer som kan brukes til beregning av posisjoner i det tredimensjonale rommet. Siden posisjonene i VRML er oppgitt i kartesiske koordinater, har det vært hensiktsmessig å benytte vektorer for å beregne plasseringen av objektene. 

I visualiseringen har vi funnet det nødvendig å ha to metoder for å generere villkårlige koordinater. Den ene genererer en villkårlig posisjon innenfor en boks med gitte dimensjoner, og den andre genererer en posisjon mellom to sfærer som begge har sentrum i origo. Begge metodene returnerer en array på tre elementer som representerer en tredimensjonal vektor.\\
Metoden for beregning av posisjon innenfor en boks returnerer en array med villkårlige verdier mellom null og angitt maksimalverdi for henholdsvis bredde, høyde og dybde.\\
\\
Metoden for beregning av koordinater mellom to sfærer er litt mer komplisert. Den trenger to parametere som angir radius på den indre og den ytre sfæren. I tillegg tar den en parameter som angir hvilken avstand som kan brukes til å gi en skalering av avstanden mellom to posisjoner. Metoden genererer først en tilfeldig vektorlengde som ligger mellom de to grensene angitt ved de to første parametrene delt på avstandsparameteren. Denne vektorlengden representerer radius r i likningen for en kule med senter i origo der x, y og z er aksene: \newline
\begin{equation} r^{2} = x^{2} + y^{2} + z^{2}\end{equation}
X-verdien settes først til et tilfeldig tall slik at $ x \in [ \: 0,  r \: ] $. Deretter settes y tilfeldig slik at
$y \in [ \: 0,  \sqrt{ r^{2} - x^{2} } \: ] $
før z-verdien til slutt beregnes ut fra r, x og y:
\begin{equation}z = \sqrt{ r^{2} - (x^{2} + y^2) }\end{equation}
De tre beregnede verdiene for henholdsvis x, y og z er alle positive flyttall. De representerer derfor kun punkter i første kvadrant. For å få negative verdier, og dermed kunne fylle en hel sfære, blir hver av verdiene tilfelig multiplisert med 1 eller -1. I tillegg multipliseres hver av verdiene med avstandsparameteren for å få tilbake ønsket skalering, og verdiene konverters til heltall før de returneres som en array på tre elementer.


\subsubsection{Fargeproblematikk} 
Dette skal omskrives til generering av farger.. 
17/4-08
Vi ønsker å generere X antall farger, 
der X er de forskjellige verdiene til et kriterie.

I VRML kan fargene skrives som en tredimensjonal vektor der rød, grønn og blå komponentene har verdier mellom 0 og 1.

Utfordringer:
Menneskeøyet er ikke spesielt godt egnet til å se forskjell på farger, 
**link** ? eller skrive om setn. 
slik at vi bør tilstrebe at 
fargene som brukes er nokså forskjellige.
Dette blir naturligvis vanskeligere dersom vi har svært mange forskjellige kriterier.

 En løsning: Filtrere ut informasjon -- ta bort noen grupper når man studerer visualiseringen, for å ikke ta feil. Vi bør også sette en max-grense for antall farger -- 
 Over et visst punkt er det ikke lenger praktisk mulig å se forskjell på fargene, og da er det ikke hensiktsmessig å bruke farger på kriteriet. Ca 20 - 30 stk???

Da vi har svart bakgrunn, 
kan vi heller ikke bruke veldig mørke toner, 
fordi disse ikke er tydelige nok.

Første utkast : Satte statiske farger og brukte de.

Deretter: Generering av farger:
Bruke tre nestede for-løkker, øke en komponent med "step" 0.2...

Regnbue -- generere roggbif -- deretter øke en "ting" og legge til ,gjenta loop.

TODO: sette inn algoritmen for fargevalg via vektorer og dens lengde...




\subsubsection{VRML\_Generator}



\section{Visualiseringsproduktene}

\subsubsection{visualisering i praksis} %Evt. programmering... 
Det første vi prøvde å visualisere var maskinnoder og hvilket os de har.
For at vår visualisering skulle passe til forskjellig antall maskiner, telte vi opp det totale antall maskiner, m.
Ved å ta kvadratroten av dette: $ n = \sqrt{m} $ kunne vi lage en grid med n * n noder.
Størrelsen på nodene ble av praktiske hensyn satt til 1 * 1 * 1 , og hver node ble satt inn med et mellomrom på 1.
Dette gjorde at vi fikk en formel for høyde og bredde på denne visualiseringen, basert på antall maskiner m:   $ h = w = 2 * \sqrt{m} $
Dette trengte vi for å kunne beregne posisjonen for et viewpoint, altså hvor "kameraet" skal stå for å kunne vise hele scenen.
Et viewpoint i VRML har som standard et synsfelt på $ \pi/4 $ grader, men kan settes fra alt til 
0 - 2 $ \pi $.
Vi valgte å beholde standard, blant annet for å unngå "distortion" --  dersom man øker eller minker for mye vil man få sammentrekninger eller "fisheye"-effekt.

Med en vinkel på 90 grader var det enkelt å beregne hvor kameraet skulle stå.
(Vi begynner i punkt 0,0,0).
TODO: Illustrasjon???
Med en høyde h og bredde b, kunne vi bruke trigonometri til å beregne kameraets x,y, og z posisjoner.
x og y settes til hhv b / 2 og h /2.
z kan regnes ut ved å beregne $ x / \tan 45 = x $  og for å få litt luft på hver side setter vi z til 3 * x. Dette resulterte i en visualisering som den i fig.: **illustrasjon?**

Neste oppgave ble nå å lage en annen visualiseringsmetode for et kriterie. 
Vi valgte å ta utgangspunkt i maskinens gateway, fordi det var et felt som nokså mange maskiner hadde, og det var ikke så altfor mange forskjellige.
For å vise tilhørighet, bestemte vi oss for å la maskinnodenes posisjon si noe om hvilken gateway de tilhørte. Sagt tydeligere: Vi tegnet opp gateways og posisjonerte nodene i nærheten av sin respektive gateway.
Ved å ta utgangspunkt i det første scriptet, endret vi det til å hente inn de forskjellige gateway-addressene.
Så lagde vi en grid basert på dette antallet og genererte en kule for hver gateway.
Deretter hentet vi inn alle maskinnavn sortert på tilhørende gateway fra databasen.
Nå kunne vi løpe gjennom listen over maskiner og tegne en firkant for hver maskin, og sette posisjonen til området rundt den respektive gatewayen.

Da dette virket, endret vi det til å sette en tilfeldig posisjon for hver maskin, og deretter flytte det mot gatewayen som en animasjon, både for en penere effekt, men også fordi vi ønsket å prøve ut bevegelse i visualisering, da dette er noe menneskeøyet oppfatter spesielt godt.
Så ved å prøve ut dette her, kunne vi bruke metodene senere i andre visualiseringer.
For å få til dette, måtte vi opprette grupper ( transforms ) for hver gateway.
Denne gruppen fikk så en posisjonsbeskrivelse med start og slutt-koordinater, hvor sluttkoordinatene er de samme som den tilhørende gateway-nodens koordinater. 
Alle maskinnoder som hadde denne gatewayen ble lagt inn i denne gruppen på et tilfeldig sted.
En animasjon er bevegelse over tid, så vi måtte også lage en klokke (timer), og rute klokkens "tikk" til posisjonsbeskrivelsen. 
Så må denne rutes videre til sin respektive gruppe, som så flytter alle nodene i gruppen mot gatewayen. Maskinnodene selv ble også tildelt en lokal. tilfeldig posisjon rundt gatewayen, så ikke alle skulle bli liggende i en klump.

Når også dette var i orden, kombinerte vi os-visualisering og gateways, slik at nodene fikk farge etter hvilket os de hadde og ble posisjonert etter hvilken gateway de tilhørte, se eksempel figur \ref{gv}.
\begin{figure}[ht]
\centering
\includegraphics[scale=0.5]{groupvisualisation.PNG} 
\caption{Group Visualisation} \label{gv}
\end{figure}

Denne visualiseringen har vi valgt å kalle en ``gruppe-visualisering med to kriterier'', fordi noder blir gruppert etter kriterier. 

Etter dette ønsket vi også å ha mulighet til å filtrere bort uønsket informasjon, for eksempel ved at man kan slå visning av grupper av operativsystem av og på.
På dette tidspunktet var ikke gruppene organisert på annen måte enn gateway, så for å få til å velge alle noder med et bestemt operativsystem, ble det nødvendig å organisere nodene annerledes.

Løsningen ble å lage nøstede grupper av maskiner, slik at vi opprettet en gruppe for hvert operativsystem. Inne i denne gruppen opprettet vi så nye grupper over forskjellige gateways, og inne i disse ble maskinene plassert.
Det er da en smal sak å få manipulert en gruppe med maskiner, og vi kan da filtrere ut maskiner basert på hvilket operativsystem de har.

Datastrukturen som ble brukt, var en hash med hasher, altså på formen:

\begin{verbatim}
	%nodes{ 
		%os1{
			machineName1 => gwAdr1,
			machineName2 => gwAdr2		  	
		}
		
		%os2{
			machineName3 => gwAdr1,
			machineName4 => gwAdr2		  	
		}			
	}
\end{verbatim}

Ved å sortere hashen på først nøkkel 1, og deretter på verdien (gwAdr), kunne vi løpe gjennom datastrukturen og generere VRML-grupper for hver unike verdi, og så plassere nodene inne i disse.

Da dette var i orden, ønsket vi å kombinere enda mer informasjon.
Alle nodene som oppfyller et boolsk kriterie ble hentet og lagt inn i en ekstra datastruktur. Så, da hver node printes, sjekket vi om vi fant nodenavnet i kriterie3. Hvis ja, la vi til en rute som trigget en animasjon på noden.
Vi testet ut flere forskjellige teknikker, for å se hva som var best. 
Til slutt endte vi opp med å sette en rotasjon på noden, slik at den spinner rundt sin egen akse, fordi dette ikke genererte for mye "visuell støy". 
Noen andre forsøk var å flytte de fram og tilbake i z-planet, eller skalere nodene opp og ned, men begge disse ble forkastet fordi vi syntes de tiltrakk seg for mye oppmerksomhet.

Heatmap / Changespiral
Vi ønsket også å lage en visualisering som kunne vise forandring i nettverket over tid. 

Det første forsøket var å generere et objekt per cluster, der objektets størrelse tilsvarer antall maskiner som oppfyller kriteriet.
Ved å hente ut alle maskiner fra databasen, sortert etter dato, kunne vi få en oversikt over størrelsen på enhver gruppe til enhver tid.
Deretter ble det opprettet en klokke, som for hver nye dato, skalerte størrelsen til gruppene etter hvor mange maskiner som ble lagt til / fjernet.
Dette fungerte fint, men svært store grupper ble veldig dominerende, slik at i stedet for å sette forholdet til 1: 1, valgte vi å prøve å sette størrelsen til  tredjeroten av antallet (n). $ x = \sqrt[3] n $ 
Dette ble bedre i forhold til at mindre grupper også ble synlige, men det var vanskelig å se forandringen i størrelse, slik at en middelvei med kvadratrot ble valgt som et minste felles multiplum.

Vi ville også forsøke å visualisere andre endringer i konfigurasjonen.
Valget falt på å basere oss på et heatmap, fordi dette var en av grunnteknikkene som vi ikke enda hadde implementert. 
Hver gang konfigurasjonen til en maskin blir oppdatert, legger vi dette inn i databasen. Så ved å hente ut alle maskiner fra databasen, sortert etter dato for endring / import, og så sjekke hva som endres: er det at maskinen går fra en gruppe til en annen, eller er det andre ting i konfigurasjonen som oppdateres?

Eks: Vi grupperer på OS. Vi begynner på den første datoen i databasen og henter ut alle maskiner som er lagt inn denne dagen. 
Datastrukturen er:
\begin{verbatim}
	\$groups{
				dato => os => antall
			}

	og \%changes{
				dato => os => antall
				}
\end{verbatim}

Vi lagrer også en hash med maskinnavn og tilhørende os, slik at om maskinens konfigurasjon blir oppdatert senere, kan vi sjekke om oppdateringen var OS eller noe annet.
Dersom det var "noe annet", øker vi changes med en.

Vi kan da se hvor mange maskiner i en os-gruppe som har oppdatert konfigurasjonen sin på et gitt tidspunkt. Dette antallet, delt på antall maskiner i gruppa totalt, gir et forholdstall mellom 0 og 1.
\begin{verbatim}
Endring i prosent per gruppe = \$changes{dato}{os} / \$groups{dato}{os} 
\end{verbatim}
En fargeInterpolator kan ta et tall fra 0 til 1 og returnere en farge.
Rekkefølgen på fargene har vi valgt å være primærfarger i et vanlig regnbuespekter fra blå til rød / fiolett. 
Ved å bruke dette tallet og rute inn til fargeinterpolatoren, kan gruppefargen settes til en farge som sier noe om hvor mange forandringer en gruppe gjennomgår, dersom ingen endring skjer er fargen blå, og dersom svært mange forandringer inntreffer, vil fargen gradvis gå over til rød / fiolett.

For å få posisjonert gruppene hensiktsmessig, forsøkte vi flere teknikker, blant annet en matrise. Men vi syntes det ble penere å organisere de i en sirkulær form, der vi plasserte de største gruppene innerst, og økte radiusen etter hvert, slik at det dannes en spiralform.
\begin{figure}[ht]
\centering
\includegraphics[scale=0.7]{spiral_manager.PNG} 
\caption{Spiral heatmap} \label{spiral}
\end{figure}

%Nodevisualisering
Visualisering som tar for seg en eller to noder var også noe vi ønsket å visualisere. I gruppevisualiseringen er det veldig mye informasjon som blir visualisert, og derfor ville vi gå ned på et litt dypere nivå for hver node. Denne visualiseringen skal primært vise forskjeller og likheter mellom to noder.

Det er mange likheter mellom denne visualiseringen og gruppevisualiseringen. Det er ønskelig at mye av den samme koden kan bli gjenbrukt, og visualiseringen skal se nogenlunde lik ut. I første omgang var det tabellene som eksisterer i databasen som skal utgjøre et gitter i visualiseringen. Disse blir hentet ut i fra databasen for hver av de to nodene, og blir slått sammen slik at alle tabellene er på samme plan. Dette vil ligne på gitterløsningen fra gruppevisualiseringen, bortsett fra at de ikke vil være kuler, kun tekst. Komponenter som tilhører de forskjellige tabellene, vil være visualisert som små bokser. Boksene vil være fargelagt etter hvilken node de tilhører. I gitteret vil det være plassert to kuler som skal representere de to nodene (maskinene). Fra disse nodene er det linjer som blir trekt fra noden og til de komponentene som de har. 


I denne visualiseringen tas det høyde for dato. Hvis man har lyst til å visualisere tilstanden til en maskin på et gitt tidspunkt, velger man det i grensesnittet og man får det opp i visualiseringen. Vi har valgt å gjøre det slik at man alltid må visualisere to maskiner. Hvis man har lyst til å se på kun en maskin, må man dessverre velge en vilkårlig andre maskin og bare se vekk i fra de komponentene den har. Det er funksjonalitet i VRML-filen for å klikke vekk de komponentene som kun tilhører den andre maskinen.

\newpage
\begin{figure}[ht]
\centering
\includegraphics[scale=0.5]{nodevisuallcompsainjarvi.PNG} 
\caption{Nodevisualisering alle komponenter} \label{Nodevisualisering1}
\end{figure}

\newpage
\begin{figure}[ht]
\centering
\includegraphics[scale=0.5]{nodevisudiffcompsainjarvi.PNG} 
\caption{Nodevisualisering forskjellige komponenter} \label{Nodevisualisering2}
\end{figure}


\subsection{nodevisu}


\subsection{pyramide}

\subsection{gruppe}

\subsection{spiral}







Det meste under denne linjen, skal enten oversettes eller strykes:\\


The program is divided into two separate parts:
dataImporter and dataVisualizer (figure ..) image

1. dataImporter
This is the part used to parse the XML-profiles, extract the wanted information and export it to a mySQL database. 

2. dataVisualizer
This part connects to the database and generates a visualisation based on which criterias and techiques the user sets.

\chapter{User guide}
User guide will be added here...

\section{Installing lcfgVisualizer}
installation guide.. 
\section{Importing XML data}
\paragraph{Prerequisites:}
Before extracting data into the database, some things should be prepared in a proper way:
The \textbf{name} of the XML file in conjunction with the \textbf{lcfg/last\_modified} field will be used as primary keys in the database.

The XML-files you want to import should each lie in a separate directory for each of the dates.

A database server should be up and running, preferrably a mySQL database.
Create an empty table to hold imported data.
Make sure the system requirements are met (see SRS section further down)

Edit the config file cfg/vcsd.cfg to fit your system and needs.
In specific, make sure the database section matches your database server and tablename.
For further info about vcsd.cfg, see section \ref{configfile} .

\subsection{Initial import}
When the config file is fully configured, and all the desired components have been declared, the extracting of data into the database can begin. Run the perl file XML\_to\_DB.pl in a terminal or on a commmand line. If everything is configured correctly, this should go smoothly. For each main component (e.g. $<$inv$>$ ) this operation takes approximately one minute on a system with 1000 XML files, depending on the Hardware and LAN/Internet speed if the database is externally located.

The script will print out the parameters and child values chosen, confirm by pressing enter for each main component.
The script will print out the number of files found in the folder, push any key to continue the import.
If some XML-files is not well-formed or have errors, the script will print a warning and the file will not be imported.
When done, the script will print out the number of errors encountered ( if any ) and the time elapsed.
You have now imported a dataset, and may go on to adding further data sets \ref{append}, or skipping to the visualisation part \ref{visualisation}.

\subsection{Appending newer data sets}
\label{append}
To append more datasets to the database, just edit vcsd.cfg and set the xmlpath-variable to reflect the folder you want to import.
It is wise (but not necessary) to keep all the components that were used in an initial import.
If you add further components that were not imported initally, the initial values will be set to 'unknown'. %skrive litt smartere om dette.. 
Be also aware of the following: If you try to import a dataset which is older than the newest dataset imported, no values will be imported!
So make sure you import all datasets in the right order, going from oldest to newest.
\section{The config file (vcsd.cfg) }
\label{configfile}
% her er noe som kanskje skal inn også 
%\subsection{XML\_to\_DB}
%The config file (vcsd.cfg) in /cfg is used to define the different filepaths and components which are going to be extracted to the database. The databaseinformation, namespace of XML-files, filepath of XML-files, and at least one component needs to be declared before using the XML to DB script. The one mandatory component in vcsd.cfg is an arbitrary child component from components/profile.
The config file can be edited with any editor.
Lines beginning with a \# is ignored.
Consists of the following parts: 
\paragraph{DatabaseInfo}
Set the connection info to fit your mysql server.

\paragraph{PathToFiles}
This path should reflect the path to the dataset you want to import, 
for instance 
xmlpath=/home/user/xml-profiles/2008-03-05

\paragraph{Namespace}
Used by libXML to parse the data files. Default value is:
\\
namespace=http://www.lcfg.org/namespace/profile-1.0

\paragraph{Component}
This is the section where you specify which fields to import into the database.
The format is :\\ 
comp1 = inv/os\\ 

\paragraph{PreferredFields}
This section specifies which imported fields to use as a \"machine description\" in some visualisation techniques. Choose some values from the components section you configured. 

A sample configuration file cfg/vcsd.cfg is shown here:

\begin{verbatim}
#! VCSD Configuration file
# Configure with care
# This is just a sample file

<DatabaseInfo>
db=lcfg
dbtype=mySQL
dbhost=localhost
dbuser=username
dbpass=password
dbport=3306
</DatabaseInfo>

<PathToFiles>
#Uncomment one of these variables below

xmlpath=E:\mydocs\profiles\profiles-2008-03-05

</PathToFiles>

<Namespace>
namespace=http://www.lcfg.org/namespace/profile-1.0
</Namespace>

<Component>
#Which components to import from the XML files
#These components must be written like: comp<number>=comp/childcomp
# where <number> is an unique integer (doesn't need to be in order)
# and comp/childcomp is an XPath expression.  
#one profile component (such as profile/domain) is mandatory

comp1=inv/domain
comp2=inv/location
comp3=inv/manager
comp4=inv/model
comp5=inv/os
comp6=inv/owner
comp7=inv/sno
comp8=network/extrahosts
comp9=network/gateway
comp10=network/gatewaydev
comp17=xinetd/enableservices
comp22=profile/domain  #MANDATORY!
</Component>

<PreferredFields>
#The fields used to display information about one specific node.
# These fields will be collected out of the database generated, not the xml-files
# Hence it is important that these values also exist in the components section
prefield1=inv/manager
prefield2=inv/owner
prefield3=inv/location
prefield4=inv/sno
prefield5=inv/model
prefield6=inv/os
prefield7=network/gateway
#prefield8=profile/group
</PreferredFields>

\end{verbatim}


\section{Visualizing data}
\label{visualisation}
Here is something on how to visualize..

Prerequisites: A modern Web browser, octaga player. 
Fire up your browser and point it to http://localhost/cgi-bin/index.cgi

From the menu, choose a visualisation technique.
Depending on the technique chosen, choose the desired number of parameters and the desired fields to cluster on.
The visualisation will be embedded in the browser window, or you can open it manually from the output folder specified in vscd.cfg.

About navigation in the vrml browser... \\
This is how you do it.. \\ For further reference, please see www.octaga.no 


About the different techniques...\\

\chapter{System reference}

\section*{}
This part of the document will contain  documentation needed by developers for maintanence and expansion of the system

\newpage


\section{DataVisualizer}

\subsection{GUI}
The GUI consists of the following files and classes: 
\paragraph{cgiFunctions.pm}
Methods for printing HTML elements such as forms, stylesheets, menu, javascripts and embed visualisations.
Dependencies: DAL.pm

\paragraph{cgi scripts}
Index.cgi -- Start page \\
nodeVisualisation.cgi \\
pyramidVisualisation.cgi\\
groupVisualisation.cgi\\
spiralVisualisation.cgi\\
Dependencies: CGI

\subsection{BLL}
The business layer.
\subsubsection{Visualisation Library}
 Consists of a library of Visualisation modules, namely:
\subsubsection{GroupVisualizer}

\subsubsection{PyramidVisualizer}

\subsection{SpiralVisualizer}

\subsection{NodeVisualizer}

\subsection{PyramidVisualizer}
This module generates the vrml for the pyramid visualization. 
The pyramid visualizer module depends on the following modules: 

\subsubsection{Method descriptions}

\paragraph{new()}
This method is a constructor generating a new PyramidVisualizer object. Six parameters are required. 
The first three represent the table name, field name and field value for the first criteria query, while the last three represent the same values for the second criteria.

\paragraph{generateWorld()}
This method is responsible for generating the VRML-file for the visualization. 
\begin{itemize}
\item[-]Parameters: none
\item[-]Return value: String
\end{itemize}
First the data is retrieved from DAL, then the size of the steps are calculated before the string for the vrml file is bulit and returned.

\paragraph{hashValueAscendingNum}
Helping method, sorts a hash by its values in ascending order. Uses the global hash \verb"%steps"


\paragraph{hashValueDescendingNum}
Helping method, sorts a hash by its values in descending order. Uses the global hash \verb"%steps"


The visualizer modules depend on the following modules: 
\begin{itemize}
\item[-]
DAL.pm
\item[-]
vrmlGenerator.pm
\end{itemize}

\subsection{VRML\_Generator}

The VRML\_Generator is the largest module and is used by all the visualisation modules. Its main task is to generate valid VRML strings based on the attributes and method calls in the visualisation modules.
It is divided into different parts: 
\paragraph{Utility methods} 
These are methods which can be used by any visualisation, such as setting color values, generating vector positions, printing routes and converting strings to "VRML-safe" syntax.

\paragraph{General VRML methods}
These methods are also generic methods which generates valid VRML code from desired parameters. 
A lot of common VRML nodes can be generated, including Timer, Transform, Group, Interpolator and Text. 
 
\paragraph{Proto methods}
Generates valid Proto nodes. (Static strings).
Proto nodes are definitions built by VRML nodes, fields and Scripts.
Used to define MachineNodes, viewpoints and menuitems and their attributes.

\paragraph{Specific methods for each Visualisation technique}
Methods used only by one specific visualisation module.

\subsection{DAL}
The Data Access Layer. \\
Files: DAL.pm \\
Connects to the database. \\
Dependencies: DBI\\

\section*{SRS System Requirement Specification}

\section*{Structure}
	Bilde / visualisering av komponenter og underprogrammer 
	\subsection*{Hardware requirements}
	
	Any newer computer (X86-compatible).

	\subsection*{Software requirements}

	
	Perl \verb#>=# 5.10 with XML::LibXML::XPathContext;
	For windows, the following packages are required to 		parse the XML files:
	\begin{itemize}
		\item[-]
		XML::LibXML
		\item[-]
		XML-LibXML-Common
		\item[-]
		XML-NamespaceSupport
		\item[-]
		XML::SAX 
	\end{itemize}	
	These packages can be retrieved from 
\verb"http://cpan.uwinnipeg.ca/PPMPackages/10xx/"	

	mySQL \verb#>=# 5.0.45
	apache webserver
	
	The client:
	A modern web browser -- tested in IE6, Mozilla Firefox, Opera, Safari .. bla
	VRML browser: recommended Octaga Player 
	
	
	

\section*{Database}

\section{Technologies}
This section will describe the technologies used throughout the project period to accomplish the final product.

\subsection{Perl}
Perl is dynamic programming language originally developed for fast text manipulation. It has been influenced by languages like C, AWK, and Lisp, and nowadays used for a wide range of tasks - e.g. network programming, GUI and web-programming, etc. Many operating systems are supported by Perl. The CPAN (Comprehensive Perl Archive Network) provides many third-party modules, which can improve and simplify various tasks.

\subsection{CGI}
The Common Gateway Interface (CGI) is a standard for interfacing external applications with an information server, e.g. HTTP servers. A CGI program is exectuted in real-time, giving the ability to display dynamic information.

Perl has CGI as a built-in module, and can use it to dynamically create web pages. 

\subsection{HTML}
The HyperText Markup Language (HTML) is used when publishing documents on the world wide web, and consists of codes which a browser interprets.

\subsection{VRML}
The Virtual Reality Modelling Language (VRML) is used to define three dimensional scenes, which allows a user to move around within its environment. VRML programs are event driven like HTML, and is commonly used to embed 3D effects on a web page. 

\subsection{MySQL}
The Structured Query Language (SQL) is a language that provides an interface to a database. MySQL is an open source software relational database management system, which is used to handle querys and transactions to a database.

Perl has a built-in module called DBI (database interface) which can interpret many types of structured query languages and

\subsection{Apache}
Apache is a web server which can be configured to run Perl::CGI and MySQL.


\section*{Installation}
Installation on Windows:

You need to install the following third-party software:

Apache, Perl, mySQL

We recommend installing activestate Perl -- link ,..

Install it to a folder, we will use \verb"C:\perl"

And then install WAMP server  -- -link

Unzip lcfgVisualizer.zip to a desired path, in our example we will use
\verb"C:/lcfgVisualiser/"

go to the folder and edit the .cgi files --- change the first line to reflect the location of your perl.exe file.

In this example, we will use \verb "#!C:\perl\bin\perl.exe -w"

To open for cgi execution in apache, you need the following lines in 
httpd.conf:

In the loadModule section, make sure these lines are not commented:
\begin{verbatim}
LoadModule alias_module modules/mod_alias.so
LoadModule cgi_module modules/mod_cgi.so
\end{verbatim}
in the section \verb"<IfModule alias_module>", add the following lines:
\begin{verbatim}
ScriptAlias /cgi-bin/ "C:/lcfgVisualizer/cgi/"

<Directory "C:/lcfgVisualizer/cgi/">
    AllowOverride None
    Options +ExecCGI Indexes
    Order allow,deny
    Allow from all
	AddHandler cgi-script .cgi .pl
</Directory>
\end{verbatim}

In the root directory of your apache server root ( default .... ), 
make a new folder named output
% vil ikke perl opprette katalogen for oss?
% i linux blir det kanskje et problem med rettigheter på katalog og filer
in cgifunctions.pm
set 
\begin{verbatim}
\$FILEPATH = "E:\\www\\output\\";
\end{verbatim}


\section*{Bugs \& known issues}
BUG: Web browser freezes / crashes
GUI: On some systems, the octaga web browser plugin does not work.
Web browser: Internet Explorer 7.0.5730.11

Solution: Change browser -- use firefox.
Platform: 
Systems running Windows XP SP2, Internet Explorer 7.0.5730.11, Octaga player 2.2.0.12

Issue: Embedded vrml player spiser cpu, har 100 prosent i cpu.
Er dette pga skjermkortdriver feks?


Error hos meg: Embedded VRML worlds does not show up in firefox
Solved --- feil i stien til embeddinga, må ta med .. foran  \$vrmlFile


BUG: Embedded VRML is not updated 
Firefox bruker cache selv om den ikke skal  det, funker ikke å force reload.
Må restarte browser for å få vist en ny visualisering.
Foreløpig løsning: ikke printe ut embeddinga, bare link,
dette hjelper også mot at internet explorer henger hvis man prøver det i IE.


BUG: Some links inside the VRML world does not work
All links point to the same viewpoint. This is a anchor issue with name conventions.. 
- Viewer: Cortona 3D viewer
Platform: All
-Visualisations affected: groupVisualizer,...

Issue: touchSensor is misplaced in VRML Player on Mac OSX.
This means that if an object is linked with a touch sensor, one must click underneath the object to activate the sensor, rather than clicking the actual object. 

Issue: DataImporter. 
If you try to import a dataset of XML files which is older than the currently newest, nothing will be imported. 
Solution: Make sure you import datasets in a correct order, from oldest to latest.

BUG: Empty fields from the database in the CGI
When trying to visualize a field which has no values at all from the database, the user interface does not give any warnings about it. The select box in the web page is empty, and it is impossible to draw a VRML file.
Solution: Go back a few steps in the web page, and select another table.


%Noe av dette kommer et eller annet sted...
\subsubsection{Hendelsesflyt for import til DB}
\begin{itemize}
\item 
Leser inn cfg fil
\item 
cfg-fila skal inneholde:
\begin{itemize}
\item 
Databaseinformasjon (username, pass, host, port, type of base)
\item 
Tabell- og kolonnenavn (inv / os) - attributt
\item 
Namespace over xml-filene
\item 
Path til zip-fil over profiler
\end{itemize}
\item 
 Tester databasetilkobling med parametre fra cfg
\item 
 Zipper opp profiler og legger de i en temporær katalog
\item 
 Deklarer en array over tabell (hovedkomponenter - eksempel inv)
 Og i denne arrayen må det legges flere nye hasher over kolonnenavn (eksempel inv/os)
\item 
Deklarer også en boolsk array over tabellene, som senere vil si i fra om operasjonenene har gått bra eller ikke
Hvis det er noen som ikke har gått OK, så kopiereres ikke tabellene tilbake.
\item 
Opprett tabeller med kolonnenavn hentet fra cfg Hvis tabell eksisterer fra før av og kolonnenavnene ikke samsvarer:
Kopier tabell og alter.
Denne nye tabellen skal det legges data i, og senere skal den overskrive den gamle
Hvis tabell eksisterer fra før av og kolonnenavnene samsvarer:
\item 
Append table.
\item 
Løpe i gjennom filer ( foreach <>)
     Deklarer man rotnode, etc
\item 
Finne  "last\_modified"  og legge den i en variabel sub getLastModified(maskinnavn)
\item 
Hvis  last\_modified  fra xml er nyere enn den i DB, fortsett
\item 
Opprett en boolsk variabel som skal holde rede på om det blir gjort noen forandringer, \$changed
\item    
Løpe i gjennom tabellparametre (hovedkomponenter)
\item 
Sjekke om parameteren eksisterer i xml-filen
Bør sjekke nivået på parameteren som kommer inn, og at det i hele tatt er verdi der.
\item 
Finne ut verdien til parameteren, og legger denne som en value til tilhørende key i hash (f.eks. "fc6" til inv/os) Ikke glem attributten hvis vi skal ha den.
\end{itemize}
Hvis databasen allerede eksisterte, må vi selecte fra databasen alle dataene fra den maskinen vi holder på med og sjekke mot hashen om det er noen nye verdier. Hvis det er det, så må vi inserte en ny rad og gi \$changed verdien "true".

\begin{itemize}
\item    
Sjekke \$changed
\item  
Hvis "true", oppdatere tabell  last\_modified med last\_modified 
\item  
Sjekke om det er noen false-verdier i den boolske arrayen
\item  
Overskrive de gamle tabellene hvis alle er OK.
\\
%\begin{verbatim}
%sub getLastModified
%{
%    my \$tempMachine = shift  ;
%   
%     Hente ut fra DAL last modified fra 			 denne maskinen
%     Returnere denne
%}
%\end{verbatim}
\end{itemize}
TODO:
Lag en tabell  last\_modified , som inneholder id, maskinnnavn og lastmodified
Denne må oppdateres hver gang det blir gjort en endring

Logge alle aktiviteter/forandringer som skjer ved hjelp av dette scriptet
 For eksempel, antall rader forandret, mange filer som var helt like, etc etc


\end{document}