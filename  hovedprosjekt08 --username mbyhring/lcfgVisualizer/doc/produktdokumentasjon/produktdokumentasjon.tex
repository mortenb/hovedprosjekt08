\documentclass[12pt,norsk,a4paper,onecolumn]{article}
\usepackage[latin1]{inputenc}
\usepackage{babel}
\usepackage{verbatim}
\usepackage{alltt}
\usepackage{graphicx}

% to reduce indent
%\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}
% Declare document specific definitions
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\tolerance = 5000
\hbadness = \tolerance
\pretolerance = 2000

\title{Produktdokumentasjon}
\date{23 Mai 2008}
\author{Lars Martin Bredal \and Morten Byhring \and Tom Erik Iversen
\and Høgskolen i Oslo, avdeling for ingeniørutdanning
\and Gruppe 08-01}

\begin{document}
\maketitle
%\setcounter{page}{10}
\newpage

\tableofcontents
\listoffigures
%\setlength{\parskip}{2ex plus 0.5ex minus 0.2ex}\newpage
\newpage
\section{Innledning}
Dette dokumentet forklarer og beskriver produktet laget av gruppe 08-01. Det beskriver teknologier brukt og oppbygning av systemet. Dokumentet er i første rekke laget for veileder og sensor. Det kreves noe forkunnskap om informasjonsteknologi for å forstå helheten av dette dokumentet. Teksten er uthevet når det skrives om spesifikke deler av programmet, for å gjøre det lettere å skille mellom kode og tekst. Produktdokumentasjon er optimalisert for papirutskrift.

\section{Beskrivelse av programmet}
LCFGVisualizer (heretter forkortet LV) sitt bruksområde er uthenting av konfigurasjonsdata og visualisering av konfigurasjons(u)likhet.  Dataene hentes fra en ekstern LCFG-server (Local ConFiGuration system). LCFG er et system for automatisk installasjon og administrasjon av konfigurasjonen for et stort antall maskiner. Filene distribuert av LCFG blir tolket av LV, og konfigurasjonsdata som egner seg til visualisering blir lagret i intern database. Disse dataene blir brukt av LV sin visualiseringsmaskin til å produsere en tredimensjonal fremstilling av datamaterialet.

\section{Verktøy}
Programmet benytter seg av flere forskjellige teknologier for å oppnå sluttresultatet. Dette avsnittet gir en kort beskrivelse av teknologiene som   benyttes av systemet. 
%Ved valg av verktøy er det flere faktorer som gjenspeiler valgene. Programmet skal være kompatibelt på flere typer systemer, og derfor har plattformuavhengige verktøy vært viktig. Til utvikling av systemet har vi valgt Perl som programmeringsspråk, på grunn av sin gode evne til å manipulere tekst. Visualisering av konfigurasjon vil bli gjort i form av VRML, for å bygge tredimensjonale scenarier. Til lagring av data brukes (My)SQL, fordi Perl tilbyr grensesnitt mellom script og database. Som grensesnitt vil VRML-filene fungere selv, men vi har også en web-løsning hvor HTML er brukt for å gi mer brukervennlig interaksjon med programmet for brukeren. Under er teknologiene beskrevet i mer detalj.


\subsection{Perl} 
Perl er et dynamisk programmeringsspråk laget først og fremst for rask tekstmanipulasjon. Det har blitt inspirert av språk som C, AWK og Lisp, og er i disse dager brukt til en bred mengde arbeidsoppgaver - for eksempel nettverksprogrammering, brukergrensesnitt, webgrensesnitt med mer. Perl har mange innebygde moduler som man kan dra nytte av, og CPAN (Comprehensive Perl Archive Network) tilbyr mange tredjepartsmoduler, som kan forbedre og forenkle forskjellige oppgaver. 

\subsection{VRML}
Virtual Reality Modelling Language er et hendelsesdrevet modelleringsspråk, designet for å utvikle tredimensjonale miljøer for distribusjon på nett. Det omfatter 3D-figurer, farger, teksturer og lyder for en virtuell verden som en bruker kan bevege seg rundt i. Språket blir tolket av en VRML-leser og presentert  på skjerm. Den nåværende spesifikasjonen, VRML 97 \footnote{http://www.web3d.org/x3d/specifications/vrml/ISO-IEC-14772-VRML97/}, støtter integrasjon av flere dynamiske programmeringsspråk. Dette tillater den virtuelle verden å være dynamisk. 

\subsection{HTML}
HyperText Markup Language er et språk utviklet for distribusjon og presentasjon av informasjon på Internett. 
\verb"HyperText" betyr at en bruker kan navigere fritt mellom forskjellige dokumenter. \verb"Markup" er hva HTML-taggene skal gjøre med teksten i dokumentet. HTML er relativt lett å lære, og er et kraftig verktøy. . HTML er i konstant utvikling for å møte nye krav og revideres av W3C. \footnote{www.w3.org}

\subsection{CGI}
Common Gateway Interface er en standard for å tilby et grensesnitt mellom en ekstern applikasjon og en informasjonsserver (for eksempel en web-server). Et CGI-program blir eksekvert i sanntid, noe som gir muligheten til å vise dynamisk informasjon. Den innebygde CGI-modulen til Perl gjør det mulig å lage og vise dynamiske websider.

\subsection{MySQL}
My Structured Query Language er et system for administrasjon av realsjonsdatabaser. MySQL tilbyr et grensesnitt mellom en bruker og en database, hvor brukeren gis mulighet til å aksessere, endre og prosessere data i databasen.

Perl har en innebygd modul kalt DBI (database interface) som kan tolke flere typer databasespråk. Dette grensesnittet kan bruke MySQL til å kjøre spørringer og transaksjoner mot en database.

\subsection{Apache}
Apache er en webtjener som kan konfigureres til å kjøre eksterne programmer gjennom CGI og MySQL.


\subsection{XML}
XML står for eXtensible Markup Language og er en standard for lagring av strukturert informasjon. Syntaksen ligner på HTML, men tillater brukeren å utvide språket med sine egne elementer.

%I vårt program har også ukjente verdier i databasen en betydning for oss.
\section{Oppbygging av programmet}
Programmet består av to seksjoner. Den ene har som oppgave å tolke XML-filer og importere data til systemets database. Den andre seksjonen tolker de importerte dataene og genererer visualiseringene. Programmet er i tillegg delt opp i en hierarkisk lagstruktur, der hvert lag har sitt ansvars- og bruksområde; dataaksess, visualisering og presentasjon. 

\begin{description}

\item[Presentasjonslaget] tilbyr brukergrensesnittet (GUI). Det er to typer brukergrensesnitt i LV: Webgrensesnittet, der brukeren velger data til visualisering, og de genererte visualiseringene, som vises med en VRML-leser.
Disse to er slått sammen i et vindu, eller kan vises hver for seg.

\item[Forretningslogikklaget] (BLL) har ansvaret for å produsere en grafisk fremstilling av dataene i databasen. Tar i mot kriterier fra GUI, henter relevant informasjon gjennom DAL, og genererer VRML-kode.

\item[Dataaksesslaget] (DAL) har ansvaret for å gjøre spørringer mot database, og returnere spørringsresultatene i hensiktsmessige datastrukturer.

\item[Importdelen] har ansvaret for å sortere ut ønsket informasjon fra XML-filer, og legge dette inn i en intern database. Dataimportereren henter parameter fra en sentral konfigurasjonsfil og setter opp datastrukturen. XML-filene blir tolket, verdier blir hentet ut og sendt videre til DAL (dataaksesslag) for å bli lagret.




\end{description}

\subsection{Import}
Skriptet \verb"XML_to_DB.pl" er ansvarlig for å importere data til databasen.
Skriptet henter først ut informasjon om hvilke data som skal importeres fra en konfigurasjonsfil og deklarerer hva som skal bli tabeller og kolonnenavn i databasen. Den sjekker mot databasen om tabellene eksisterer fra før, og gjør eventuelle endringer hvis databasen ikke samsvarer med gjeldende konfigurasjon. Modulen \verb"Perl::LibXML" brukes til å tolke XML-filene. 

I hver fil er det en obligatorisk komponent som kalles \verb"<last_modified>", som angir den datoen siste endring er blitt gjort fra LCFG-server. Denne datoen blir hentet opp av skriptet, som går videre til neste fil hvis maskin og dato allerede er lagt inn i database. Selv om det er ny dato i forhold til den som finnes i databasen, betyr ikke det at dataene som skal importeres er endret.  Derfor kontrollerer skriptet om de nye verdiene allerede ligger i databasen, og legger dem bare  til hvis de faktisk er endret.

\subsection{DAL}

Modulen \verb"DAL.pm" fungerer som vårt dataaksesslag. Den har to bruksområder; hente ut informasjon fra database til BLL, og legge inn data fra importskriptet  \verb"XML_to_DB.pl". 

Metodene for import og ekstrahering av verdier er generiske. Det vil si at databasespørringene ikke har tabell eller felt angitt, men får dette som parametere fra overliggende lag.
Det som i hovedsak skiller disse metodene fra hverandre er oppbygningen til SQL-spørringene og datastrukturen på returverdiene.
Siden databasestrukturen kan endres, har DAL også metoder for å beskrive den gjeldende databasestrukturen.

\subsubsection*{Viktige metoder}

\begin{description}
\item[new()]
\begin{description}
\item[]
\item[Antall parameter:] Ingen

\item[Returverdi:] Referanse til opprettet objekt
\end{description}
Metoden bruker først hjelpemetoder innad i klassen, for å hente parameter fra en lokal konfigurasjonsfil. Der ligger blant annet tilkoblingsinformasjon til databasen. Returnerer så en referanse til seg selv som objekt.

\item[getVSCDTables()]
\begin{description}
\item[]
\item[Antall parameter:] Ingen

\item[Returverdi:] Tabell med strenger som representerer de gyldige tabellene i databasen
\end{description}
Søker etter tabeller i databasen som oppfyller våre spesifikke krav til tabellstruktur (\verb"machinename" og \verb"last_modified" som primærnøkkel) og returnerer en tabell over disse. Ved import av en ekstern database er denne nyttig, siden det da er mulig at tabellene i den nye databasen ikke samsvarer med konfigurasjonsfilen. Systemet kan dermed fortsatt kunne bruke den nye databasen.


\item[getNodeInformation()]
\begin{description}
\item[]
\item[Antall parameter:] 1(2) 
			(Streng maskinnavn, Streng dato (valgfritt))

\item[Returverdi:] Sammenfiltret hash 
			(tabellnavn \verb"=>" feltnavn \verb"=>" feltverdi)
\end{description}
Henter alle de nyeste verdiene til en maskin i en database. Sender man med dato, vil den returnere den nyeste informasjonen opp til denne datoen. Metoden returnerer en hash over tabellnavn som peker på hasher over feltnavn som igjen peker på deres respektive verdier. \verb"getAllNodesInformation()" er en lignende metode, som returnerer en hash-struktur med informasjon om alle nodene registrert i databasen.

\item[getAllNodes()]
\begin{description}
\item[]
\item[Antall parameter:] Ingen
\item[Returverdi:] Tabell over alle maskinnavn i databasen
\end{description}
Henter ut alle nodenavn som er registrert i databasen ved hjelp av \verb"profile"-tabellen. \verb"<profile>" er den eneste komponenten som er obligatorisk under \verb"<components>" i XML-filene. Spørringen innad i metoden ligger statisk. 

\item[getNodesWithChosenCriteriaHash()]
\begin{description}
\item[]
\item[Antall parameter:] 3 \linebreak (Streng tabellnavn, Streng feltnavn, Streng verdi)

\item[Returverdi:] Hash (Maskinnavn \verb"=>" verdi)
\end{description}
Henter alle noder som oppfyller en bestemt verdi. 

\item[Spesielle variable]
\begin{description}
\item[]
\item[\%preferredFields] er en hash over ønsket visualiseringsinformasjon
\item[\$VRMLFILEPATH] er filkatalogen til utskriftsfil
\end{description}
\end{description}

\subsection{Forretningslag}

\subsubsection{VRML\_Generator}

VRML\_Generator er den største klassen i systemet, og brukes av alle visualiseringsmodulene. Klassens hovedoppgave er å generere gyldig VRML-kode basert på attributter og metoder som blir kalt av de ulike visualiseringsmodulene. Klassen er delt opp i følgende seksjoner:

\paragraph{Nyttemetoder:}
Dette er metoder som kan brukes av enhver visualiseringsteknikk. Typiske funksjoner inkluderer generering av ulike farger og posisjoner, samt konvertering av tekststrenger til gyldig VRML-syntaks.

\paragraph{Generelle VRML-metoder:}
Dette er også felles, generiske metoder som returnerer vanlige VRML-noder, blant annet \verb"Timer", \verb"Transform", \verb"Group", \verb"Interpolator" og \verb"Text". 

\paragraph{Definisjons- og protometoder}
Protonoder er egendefinerte nodetyper som består av en eller flere VRML-noder, felt og \verb"Scripts". Først defineres nodens oppbygging, deretter kan det opprettes objekter av denne.
Disse brukes i visualiseringene til å definere utseende og oppførsel til blant annet maskinnoder, synsvinkler (Viewpoints) og menyer.Det er to varianter av Protometodene. Den ene varianten genererer statiske strenger som  definerer VRML Protonoder. Den andre lager en deklarasjon av et objekt av den korresponderende Protodefinisjonen. For å benytte en Proto i VRML må først definisjonsmetoden kalles en gang for å angi definisjonen, og deretter å kalles deklarsjonsmetoden for hvert objekt som skal opprettes.

For en mer utdypende forklaring av VRML-noder og syntax, referer til VRML97 Spec, kilde....

\paragraph{Generelle metoder for visualisering:}
Denne seksjonen inneholder metoder som genererer noen egendefinerte VRML-noder som kan brukes av alle visualiseringene. Det er metoder for å lage grupperingsnoder, start/stopp-knapp, en kalender og maskinnoder. Den kanskje viktigste metoden i denne seksjonene genererer et skjelett for menyen som brukes av alle visualiseringsteknikkene. 

\begin{description}
\item[vrmlHUD()]
\begin{description}
\item[]
\item[Antall parameter:] 4 \linebreak
(Streng children, Flyttall x, Flyttall y, Flyttall z)
\item[Returverdi:] Streng av VRML-kode
\end{description}
Metoden tar imot en streng som inneholder vrml-koden for alle menyelementene, og tre flyttall som angir størrelsen på en sensor som sørger for å holde menyen i riktig posisjon. Returverdien er en ny streng som inneholder den komplette VRML-koden for menyen.
\end{description}
\paragraph{Spesifikke metoder for hver visualiseringsteknikk:}
Denne seksjonen er videre delt opp i en del for hver spesielle teknikk.
Her legges spesifikke metodekall som kun brukes av en enkelt visualisering. Spisalvisualiseriongen har ingen metoder i denne seksjonen.


\paragraph{Metoder brukt av gruppevisualiserer:} Det er  to spesielle metoder som benyttes for å generere gruppevisualiseringen. 
\begin{description}
\item[]
\item[criteria2NodesAnchorNavi()]
\begin{description}
\item[]
\item[Antall parameter:] Tabell av tekster
\item[Returverdi:] Streng av VRML-kode
\end{description}
Denne metoden lager VRML-koden for grupperingsnodene.  Metoden bruker antallet parametere til å beregne posisjoner for nodene og oppretter en grupperingsnode for hver streng i parameterlista. For hver av disse beregnes et VRML-viewpoint for å se noden med tilhørende satellitter på nært hold. I tillegg beregnes et standard viewpoint der alle gruppene er synlige.
\item[groupVisDefNodes()]
\begin{description}
\item[]
\item[Antall parameter:] Hash med maskinnavn som nøkler. 
\item[Returverdi:] Streng med VRML-kode
\end{description}
Denne metoden lager VRML-koden for elementene som skal settes inn i HUD-menyen i tillegg til et sett \verb"Script"-noder for å styre av visning av hver maskintype. Først lager metoden ett menyelement som brukes til å starte animasjonen av maskinene, og ett som brukes for å slå av og på visning av tredje kriterium. Deretter genereres et menyelement for hver nøkkelverdi i hashen. Disse bygges opp av nøkkelteksten og en farget boks som senere også brukes for å representere en maskin med tilsvarende verdi. Fargen på boksen løper mellom 36 forskjellige verdier fra den globale tabellen \verb"@colors", noe som betyr at dersom antallet verdier i hashen overstiger dette, vil samme farge brukes på nytt. Definisjonen av boksen som genereres vil derimot være unik slik at de tilhørende maskinene kan filtreres ut i visualiseringen.
\end{description}

\paragraph{Metoder brukt av pyramidevisualisereren:}
Det er to metoder som er spesielle for pyramidevisualiseringen. Metoden \verb"pyramidMenuItems()" lager VRML-kode for menyelementene til HUD-menyen, mens metoden \verb"pyramidStep()" lager VRML-koden for et pyramidetrinn.

\paragraph{Metoder brukt av nodevisualisereren:}
Her ligger metoder som bare brukes av nodevisualiseringen. Metoden \verb"defNodes()" genererer satelittnodene og menyen, og virker på samme måte som metoden for \verb"groupVisDefNodes()"  i gruppevisualisereren. Metoden \verb"vrmlStaticGridTransforms()" genererer vrmlkoden for de to nodene som skal sammenlignes og \verb"vrmlMakeILS()" lager forbindelseslinjene mellom disse og satelittnodene.


\subsubsection{Visualiseringsteknikkene}
Felles for alle visualiseringsteknikkene er at de tar imot et eller flere felter fra databasen, og danner grupper basert på de forskjellige verdiene som feltene kan ha. En visualisering dannes av ett eller flere slike kriterier, og de ulike teknikkene utformer gruppene visuelt. Alle visualiseringsteknikkene avhenger av \verb"VRML\_Generator.pm" for generering av VRML-kode, og \verb"DAL.pm" for databaseinformasjon. 

\subsubsection{GroupVisualizer.pm}

Denne klassen lager en visualisering der alle maskinene først blir fargekodet og deretter plassert rundt en tilhørende grupperingsnode basert på henholdsvis første og andre kriterium. I tillegg kan man velge å sette et tredje kriterium som blir markert ved at noden er snudd 45 grader og roterer rundt y-aksen. 

\paragraph{Viktige metodekall}
\begin{description}
\item[new()]
\begin{description}
\item[]
\item[Antall parameter:] 4 påkrevde 
( string tabell, string felt, string tabell2, string felt2) 
+ 3 valgfrie (string tabell3, string felt3, string verdi3)
\item[Returverdi:] En referanse til opprettet objekt
\end{description}
Ved opprettelse av GroupVisualizer-objekter kreves fire parameter som angir tabell og felt for henholdsvis første og andre kriterium. Hvis man vil sette det tredje kriteriet, kan man sende med ytterligere tre parameter for å angi tabell, felt og verdi for dette.

\item[generateWorld()]
\begin{description}
\item[]
\item[Antall parameter:] Ingen
\item[Returverdi:] Streng med VRML-kode
\end{description}
er hovedmetoden som står for selve visualiseringen. Først henter metoden de nødvendige dataene via DAL.pm. Dataene lagres i en hash for hvert kriterium. For første og andre kriterium inneholder hashen maskinnavn og verdi, mens hashen for tredje kriterium kun inneholder maskinnavnet siden verdien allerede er kjent. Deretter genereres VRML-fila ved hjelp av metodene \verb"makeDefNodes()" og \verb"makeNodes()" i tillegg til metoder i klassen VRML\_Generator.

\item[makeDefNodes()]
\begin{description}
\item[]
\item[Antall parameter:] Ingen
\item[Returverdi:] Streng med VRML-kode
\end{description}
Genererer et sett med definisjonsnoder der hver distinkte verdi av første kriterium representeres av en farge. Disse nodene brukes som grunnlag for menyen og for farge på hver maskin.

\item[makeNodes()]
\begin{description}
\item[]
\item[Antall parameter:] Ingen

\item[Returverdi:] Streng med VRML-kode
\end{description}
Genererer vrmlkode for alle maskinene. Metoden løper gjennom de tre hashene og plasserer maskinene i grupper basert på andre kriterium, mens definisjonsnodene som ble laget av \verb"makeDefNodes()" brukes som grunnlag for fargen.  Det tredje kriteriet representeres ved å sette en boolsk variabel som utløser animasjon av maskinen.
\end{description}

\subsubsection{PyramidVisualizer.pm}
Denne klassen visualiserer grupper i form av en pyramide med tre trinn. Det nederste trinnet representerer alle maskiner som finnes i databasen; trinnet i midten representerer alle maskiner som oppfyller et gitt kriterium; og det øverste representerer maskinene som både oppfyller kriteriet fra trinn to, samt nok et kriterium.

\paragraph{Viktige metodekall}
\begin{description}
\item[new()]
\begin{description}
\item[]
\item[Antall parameter:] 6 
(string tabell, string felt, string verdi,
string tabell2, string felt2, string verdi2)
\item[Returverdi:] Referanse til opprettet objekt.
\end{description}
De tre første parameterne som kreves ved opprettelse av et PyramidVisualizer-objekt representerer tabell, felt og verdi i databasen for det første kriteriet som skal tilfredsstilles, mens de tre siste representerer de tilsvarende verdiene for det andre kriteriet.

\item[generateWorld()]
\begin{description}
\item[]
\item[Antall parameter:] Ingen
\item[Returverdi:] Streng med VRML-kode
\end{description}
Selve pyramiden genereres fra denne metoden, som først henter ut data fra databasen via modulen DAL.pm, for så å beregne størrelsen på hvert trinn og lage VRML-koden ved hjelp av modulen VRML\_Generator.pm.
\end{description}
%Resultatet vises i figur **sett inn fint bilde her**.


\subsubsection{Nodevisualizer.pm}
Denne klassen lager en visualisering som sammenligner komponentinformasjonen til to maskiner. De to maskinene i parameterlista er angitt som noder i visualiseringen, og peker på tilhørende komponenter. De tilhørende tabellene til komponentene utgjør et gitter, og komponentene er gruppert under disse. 

Klassen henter nodeinformasjon om hver av maskinene fra DAL, og slår disse sammen til én datastruktur. Blir det ikke angitt dato, hentes nyeste informasjon fra hver av maskinene. Hjelpemetodene innad i klassen bruker globale variable, og trenger derfor ingen parameter.

\paragraph{Viktige metodekall}
\begin{description}
\item[new()]
\begin{description}
\item[]
\item[Antall parameter:] 3 
(string maskinnavn1, string maskinnavn2, Date dato)
\item[Returverdi:] Referanse til opprettet objekt
\end{description}
Konstruktøren som oppretter og returnerer en referanse til objekt av Nodevisualizer.pm.

\item[generateWorld()]
\begin{description}
\item[]
\item[Antall parameter:] Ingen
\item[Returverdi:] Streng med VRML-kode
\end{description}
Dette er hovedmetoden for selve visualiseringen. Den genererer VRML-kode ved hjelp av de lokale metodene \verb"makeDefNodes()" og \verb"makeNodes()". Metoden henter også ut generell VRML-kode fra VRML\_Generatoren, og returnerer til slutt koden i form av en strengvariabel.

\item[makeDefNodes()]
\begin{description}
\item[]
\item[Antall parameter:] Ingen
\item[Returverdi:] Streng med VRML-kode
\end{description}
Genererer et sett med definisjonsnoder ut fra tre forskjellige fargedistinksjoner; én for komponentene til første maskin, én for komponentene til andre maskin og én for komponenter som har lik konfigurasjon. Disse nodene vil brukes som grunnlag for menyen og for komponentnoder som vil tilhøre de tre fargene. 

\item[makeNodes()]
\begin{description}
\item[]
\item[Antall parameter:] Ingen

\item[Returverdi:] Streng med VRML-kode
\end{description}
Genererer alle komponenter tilhørende noder i gitteret og linjene som skal bli trukket fra maskin til komponent. Komponentene blir plassert i grupper basert på hvilke tabeller de er hentet fra, og får farge etter hvilken maskin de tilhører. 
\end{description}

\subsubsection{SpiralVisualizer.pm}
Denne klassen tar imot et kriterium og genererer en sfære per unike verdi, der sfærens radius bestemmes av antallet maskiner med sammenfallende verdier.
Sfærene plasseres i en spiralform etter størrelse, hvor de største gruppene utgjør sentrum av spiralen.
Dersom det er flere datasett tilgjengelig i databasen, og en økning eller reduksjon av antall enkeltnoder i en gruppe forekommer, vil det animeres en skalering av sfærens radius i henholdsvis positiv eller negativ retning, sortert på dato fra eldste til nyeste konfigurasjon.
I tillegg vil også sfærenes farge endres, dersom det forekommer andre forandringer i konfigurasjonen til nodene som tilhører en gruppe.
Fargeendringen baserer seg på forholdet mellom antall oppdateringer delt på totalt antall maskiner i en gruppe, og det er mulig å endre hvor stort utslaget skal være i farge ved å endre variabelen \$\verb"changeFactor".


\paragraph{Viktige metodekall}
\begin{description}
\item[new()]
\begin{description}
\item[]
\item[Antall parameter:] 2 
( string tabell, string felt)
\item[Returverdi:] Referanse av opprettet objekt
\end{description}
Oppretter en instans av Spiralvisualisereren, og returner en referanse til objektet. 

\item[Spesielle variable]
\begin{description}
\item[]
\item[\$changeFactor] (int)
\end{description}
\end{description}

\subsection{Brukergrensesnitt}

Det er to måter å få bruker til å visualisere på; én ved å skrive perl-script som sender med kriterier til en visualiseringsteknikk, eller bruke web-grensesnittet som følger med. For hver visualiseringsteknikk i BLL, er det opprettet et Perl-skript som bruker CGI-protokollen til å dynamisk lage HTML fra BLL. Disse websidene muliggjør selektering av kriteria i form av lister. 
VRML-filen i seg selv fungerer som et brukergrensesnitt. 

\section{Sentrale datastrukturer}

\subsection{Database}
MySQL (5.0.x) tjener programmets interne database.

Datastrukturen spesifiseres ut fra konfigurasjonsfilen, hvor tabell- og feltnavn er definert. Tabellnavnet representerer komponenter fra XML-filene, og barnenoder av disse utgjør kolonnenavn. Maskinnavn og `last\_modified' utgjør primærnøkkelen i disse, og de resterende feltene er barnenoder av hovedkomponentene.

\begin{figure}[!h]
\centering
\includegraphics[scale=0.4]{DBModel.PNG} 
\caption{Eksempel på tabeller} \label{eksempel}
\end{figure}



\section{Videre utvidelser}

Visualiseringsmotoren er oppbygd i moduler, og det gjør det mulig å lage nye visualiseringsteknikker. 

Metoden for å sikre SQL-spørringer bør bli utvidet til å sikre absolutt alle mulige tegn.

\end{document}