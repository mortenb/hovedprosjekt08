\documentclass[12pt,a4paper]{report}
\usepackage[latin1]{inputenc}
\usepackage[norsk]{babel}
\usepackage{verbatim}
\usepackage{alltt}
\usepackage{graphicx}

% to reduce indent
\setlength{\parindent}{0pt}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}
%
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\title{Produktdokumentasjon}
\begin{document}
\setcounter{page}{10}
\section*{Forord}
Her kommer forordet. Hvem er dette for osv
\newpage
\setlength{\parskip}{0ex}

\tableofcontents
\listoffigures
%\setlength{\parskip}{2ex plus 0.5ex minus 0.2ex}\newpage


\chapter{Beskrivelse av programmet}
Hva det gjør?
LCFGvisualizer er et program som gjør om masse tekst til et 3d-bilde.

\section{Teknologi}
De forskjellige teknologiene brukt i systemet blir beskrevet i denne seksjonen.

\subsection{Perl}
Perl er et dynamisk programmeringsspråk laget først og fremst for rask tekstmanipulasjon. Det har blitt inspirert av språk som C, AWK og Lisp, og er i disse dager brukt til en bred mengde arbeidsoppgaver - for eksempel nettverksprogrammering, brukergrensesnitt, webgrensesnitt og mer. Perl har mange innebygde moduler som man kan dra nytte av, og CPAN (Comprehensive Perl Archive Network) tilbyr mange tredjeparts moduler, som kan forbedre og forenkle forskjellige oppgaver.

\subsection{CGI}
Common Gateway Interface (CGI) er en standard for å gi et grensesnitt mellom en ekstern applikasjon og en informasjonsserver (for eksempel en HTTP-server). Et CGI-program blir eksekvert i samtid, noe som gir muligheten til å vise dynamisk informasjon.

Ved å dra nytte av den innebygde CGI-modulen til Perl, gir det muligheten til å lage og vise dynamiske websider.

\subsection{HTML}
HyperText Markup Language (HTML) er brukt til å publisere dokumenter på web, og er sammensatt av kode og tagger som en nettleser tolker.

\subsection{VRML}
Virtual Reality Modelling Language (VRML) er et språk hvor man definerer scener, som gir en bruker muligheten til å bevege seg rundt i et tredimensjonalt miljø. VRML er mye brukt til å legge til tredimensjonale effekter på en webside. 

\subsection{MySQL}
MySQL (My Structured Query Language) er en databasemotor som sitter som et lag oppe på en SQL (Structured Query Language) database. MySQL brukes til å gi et grensesnitt mellom bruker og database, hvor man kan aksessere, endre og prosessere data i en database.

Perl har en innebygd modul kalt DBI (database interface) som kan tolke flere typer databasespråk, og det kan bruke MySQL til å kjøre spørringer og transaksjoner mot en database.

\subsection{Apache}
Apache er en web server som kan bli konfigurert til å kjøre CGI-programmer og MySQL.

\section{Sentrale datastrukturer}

\subsection{Database}


%I vårt program har også ukjente verdier i databasen en betydning for oss.
\section{Oppbygning av programmet}

XML-filene inneholder mye konfigurasjonsinformasjon, og det er ikke alle komponentene man ønsker å visualisere. 
\newline\newline
I data import delen av programmet, blir det valgt ut ønskede komponenter til visualisering. De foretrukne komponentene blir lagt inn i en database, og er ved hjelp dataimportereren ferdigstilt til å bli grafisk fremstilt.

\subsection{DataImporter}

Den lokale konfigurasjonsfilen inneholder de komponenter som skal bli ekstrahert fra XML-filene og bli lagt til i databasen, og namespace som tilhører dem. 

Vår importer henter først ut all informasjon fra konfigurasjonsfilen, og redegjør hva som skal bli tabeller og kolonnenavn i databasen. Den sjekker i mot databasen om tabellene eksisterer fra før av, og gjør eventuelle endringer hvis databasen ikke samsvarer med gjeldende konfigurasjon. Importeren bruker LibXML modulen til å tolke profilfilene. I hver eneste fil er det en obligatorisk komponent som kalles `last\_modified' hvor datoen for siste endring fra LCFG-server er blitt gjort. Denne datoen blir hentet opp av scriptet, og går til neste fil hvis maskin og dato allerede er lagt inn i database. Selvom det er ny dato `last\_modified' i forhold til databasen, trenger vi å forsikre oss om at vi ikke legger inn redundant data. Derfor sjekker scriptet om de nye verdiene allerede ligger der, og legger de til hvis det er nye verdier.

\subsection{DataVisualizer}

\subsubsection{VRML\_Generator}
\begin{verbatim}
Avhengigheter: ingen

Konstruktør: new()

Antall parametere: ingen 
\end{verbatim}

VRML\_Generator er den største klassen i systemet, og brukes av alle Visualiseringsmodulene. Klassens hovedoppgave er å generere gyldig VRML-kode basert på attributter og metoder som kalles av Visualiseringsmodulene.
Klassen er delt opp i følgende seksjoner:

\paragraph{Utility methods}
Dette er metoder som kan brukes av enhver visualiseringsteknikk. Typiske funksjoner inkluderer generering av ulike farger og posisjoner, samt konvertering av tekststrenger til gyldig VRML-syntaks.

\paragraph{General VRML methods}
Disse metodene er også felles, generiske metoder som returnerer vanlige VRML-noder, blant annet Timer, Transform, Group, Interpolator og Text. 

\paragraph{Proto methods}
Proto-noder er egendefinerte nodetyper som består av en eller flere VRML-noder, felter og Scripts. Først defineres nodens oppbygging, deretter kan det opprettes objekter av denne.
Disse brukes i visualiseringene til å definere utseende og oppførsel til blant annet maskin-noder, viewpoints og menyer.Det er to varianter av Proto-metodene. Den ene varianten genererer statiske strenger som  definerer VRML Proto-noder. Den andre lager en deklarasjon av et objekt av den korresponderende Proto-definisjonen. For å benytte en Proto i VRML må først definisjonsmetoden kalles en gang for å angi definisjonen, og deretter å kalles deklarsjonsmetoden for hvert objekt som skal opprettes.

For en mer utdypende forklaring av VRML-noder og syntax, referer til VRML97 Spec, kilde....

\paragraph{General methods for visulization}
Denne seksjonen inneholder metoder som genererer noen egendefinerte VRML-noder som kan brukes av alle visualiseringene. Det er metoder for å lage grupperingsnoder, start/stopp-knapp, en kalender og maskinnoder Den kanskje viktigste metoden i denne seksjonene genererer et skjelett for menyen som brukes av alle visualiseringsteknikkene. 

\subparagraph{vrmlHUD()}
\begin{verbatim}
parametere: 4 (string children, float x, float y, float z)
returverdi: string
\end{verbatim}
Metoden tar imot en streng som inneholder vrml-koden for alle menyelementene og tre
flyttall som angir størrelsen på en sensor som sørger for å holde menyen i riktig posisjon.
Returverdien er en ny streng som inneholder den komplette vrmlkoden for menyen.

\paragraph{Specific methods for each Visualisation technique}
Denne seksjonen er videre delt opp i en del for hver spesielle teknikk.
Her legges spesifikke metodekall som kun brukes av en enkelt visualisering. 

\subparagraph{GroupVisulizer specific}

\subparagraph{criteria2NodesAnchorNavi()}
\begin{verbatim}
parametere: en array av tekster
returverdi: string
\end{verbatim}
Denne metoden lager VRML-koden for grupperingsnodene.  Metoden bruker antallet parametere til å beregne posisjoner for nodene og oppretter en grupperingsnode for hver streng i parameterlista. For hver av disse beregnes et VRML-viewpoint for å se noden med tilhørende satellitter på nært hold. I tillegg beregnes et standard viewpoint der alle gruppene er synlige.

\subparagraph{groupVisDefNodes()}
\begin{verbatim}
parametere: en hash av tekster
returverdi: string
\end{verbatim}
Denne metoden lager VRML-koden for elementene som skal settes inn i HUD-menyen i tillegg til et sett Script-noder for å styre av visning av hver maskintype. Først lager metoden ett menyelement som brukes til å starte animasjonen av maskinene, og ett som brukes for å slå av og på visning av tredje kriterium. Deretter genereres et menyelement for hver nøkkelverdi i hashen. Disse bygges opp av nøkkelteksten og en farget boks som senere også brukes for å representere en maskin med tilsvarende verdi. Fargen på boksen løper mellom 36 forskjellige verdier fra den globale arrayen \verb"@colors", noe som betyr at dersom antallet verdier i hashen overstiger dette, vil samme farge brukes på nytt. Definisjonen av boksen som genereres vil derimot være unik slik at de tilhørende maskinene kan filtreres ut i visualiseringen.

\subparagraph{PyramidVisulizer specific}
Det er to metoder som er spesielle for pyramidevisualiseringen. Metoden \verb"pyramidMenuItems()" lager vrmlkode for menyelementene til HUD-menyen, mens metoden \verb"pyramidStep()" lager vrml-koden for et pyramidetrinn.
\subparagraph{NodeVisualizer specific}
Her ligger metoder som bare brukes av nodevisualiseringen. Metoden \verb"defNodes()" genererer satelittnodene og menyen, og virker på samme måte som metoden for \verb"groupVisDefNodes()"  i gruppevisualisereren. Metoden \verb"vrmlStaticGridTransforms()" genererer vrmlkoden for de to nodene som skal sammenliknes og \verb"vrmlMakeILS()" lager forbindelseslinjene mellom disse og satelittnodene.

\subsection{Visualiseringsproduktene}
Felles for alle visualiseringsteknikkene, er at de tar imot et eller flere felter fra databasen, og danner grupper basert på de forskjellige verdiene som feltene kan ha. En visualisering dannes av ett eller flere slike kriterier, og de ulike teknikkene utformer gruppene visuelt.

\subsubsection{GroupVisualizer.pm}
\begin{verbatim}
Avhengigheter:

VRML_Generator.pm
DAL.pm

Konstruktør: new()
Antall parametere: 4 påkrevde 
( string tabell, string felt, string tabell2, string felt2) 
+ 3 valgfrie (string tabell3, string felt3, string verdi3)
\end{verbatim}

Denne klassen lager en visualisering der alle maskinene først blir fargekodet basert på kriterium 1 og plassert rundt en tilhørende grupperingsnode basert på kriterium 2. I tillegg kan man velge å sette et tredje kriterium som blir markert ved at noden er snudd 45 grader og roterer rundt y-aksen. Ved opprettelse av GroupVisualizer-objekter med metoden \verb"new()" kreves fire parametere som angir tabell og felt for henholdsvis kriterium 1 og 2. Hvis man vil sette det tredje kriteriet, kan man sende med ytterligere tre parametere for å angi tabell, felt og verdi for dette.

\paragraph{Viktige metodekall}

\paragraph{generateWorld()}
er hovedmetoden som står for selve visualiseringen. Først henter metoden de nødvendige dataene via DAL.pm. Dataene for lagres i en hash for hvert kriterium. For første og andre kriterium inneholder hashen maskinnavn og verdi, mens hashen for tredje kriterium kun inneholder maskinnavnet siden verdien allerede er kjent. Deretter genereres vrml-filen ved hjelp av metodene \verb"makeDefNodes()" og \verb"makeNodes()" i tillegg til metoder i klassen VRML\_Generator.

\paragraph{makeDefNodes()} genererer et sett med definisjonsnoder der hver distinkte verdi av kriterium 1 representeres av en farge. Disse nodene brukes som grunnlag for menyen og for farge på hver maskin.

\paragraph{makeNodes()} genererer vrmlkode for alle maskinene. Metoden løper igjennom de tre hashene og plasserer maskinene i grupper basert på andre kriterium, mens definisjonsnodene som ble laget av \verb"makeDefNodes()" brukes som grunnlag for fargen.  Det tredje kriteriet representeres ved å sette en boolsk variabel som utløser animasjon av maskinen.


\subsubsection{PyramidVisualizer.pm}
\begin{verbatim}
Avhengigheter:

VRML_Generator.pm
DAL.pm

Konstruktør: new()
Antall parametere: 6 ( string tabell, string felt, string verdi,
string tabell2, string felt2, string verdi2)

Viktige metodekall:
generateWorld() -- returnerer visualiseringen
\end{verbatim}
Denne klassen visualiserer grupper i form av en pyramide med tre trinn. Det nederste trinnet representerer alle maskiner som finnes i databasen. Trinnet i midten representerer alle maskiner som oppfyller et gitt kriterium, og det øverste representerer maskinene som både oppfyller kriteriet fra trinn to, samt nok et kriterium.\newline


De tre første parametrene som kreves ved opprettelse av et PyramidVisualizer-objekt med metoden \verb"new()" representerer tabell, felt og verdi i databasen for det første kriteriet som skal tilfredsstilles, mens de tre siste representerer de tilsvarende verdiene for det andre kriteriet. Selve pyramiden genereres fra metoden \verb"generateWorld()" som først henter ut data fra databasen via modulen DAL.pm, for så å beregne størrelsen på hvert trinn og lage vrml-koden ved hjelp av modulen VRML\_Generator.pm.
%Resultatet vises i figur **sett inn fint bilde her**.


\subsubsection{Nodevisualizer.pm}
\begin{verbatim}
Avhengigheter:

VRML_Generator.pm
DAL.pm

Konstruktør: new()
Antall parametre: 3 (string maskinnavn1, string maskinnavn2, Date dato)
\end{verbatim}
Denne klassen lager en visualisering som sammenligner komponentinformasjonen til to maskiner. De to maskinene i parameterlista er angitt som noder i visualiseringen, og peker på tilhørende komponenter. De tilhørende tabellene til komponentene utgjør et gitter, og komponentene er gruppert under disse. 

Klassen henter nodeinformasjon om hver av maskinene fra DAL, og slår disse sammen til én datastruktur. Blir det ikke angitt dato, hentes nyeste informasjon fra hver av maskinene.  

\paragraph{Viktige metodekall}
\paragraph{generateWorld()} er hovedmetoden for selve visualiseringen. Den genererer VRML-kode ved hjelp av de lokale metodene makeDefNodes() og makeNodes() og henter ut generell VRML-kode fra VRML\_Generatoren, og returnerer denne koden i form av en strengvariabel.

\paragraph{makeDefNodes()} genererer et sett med definisjonsnoder ut i fra tre forskjellige fargedistinksjoner; én for komponentene til første maskin, én for komponentene til andre maskin og én for komponenter som har like konfigurasjon. Disse nodene vil brukes som grunnlag for menyen og for komponentnoder som vil tilhøre de tre fargene. 

\paragraph{makeNodes()} genererer alle komponenter tilhørende noder i gitteret og linjene som skal bli trukket fra maskin til komponent. Komponentene blir plassert i grupper basert på hvilke tabeller de er hentet fra, og får farge etter hvilken maskin de tilhører. 
\begin{figure}[ht]
\centering
\includegraphics[scale=0.3]{nodevisuallcompsainjarvi.PNG} 
\caption{Nodevisualisering alle komponenter mellom to maskiner} \label{Nodevisualisering1}
\end{figure}


\begin{figure}[ht]
\centering
\includegraphics[scale=0.3]{nodevisudiffcompsainjarvi.PNG} 
\caption{Nodevisualisering forskjellige komponenter mellom to maskiner} \label{Nodevisualisering2}
\end{figure}




\subsubsection{SpiralVisualizer.pm}

\begin{verbatim}
Avhengigheter:

VRML_Generator.pm
DAL.pm

Konstruktør: new()
Antall parametere: 2 ( string tabell, string felt)
Viktige metodekall:
generateWorld() -- returnerer visualiseringen

Spesielle variable: 
$changeFactor (int)

\end{verbatim}
Denne klassen tar imot et kriterie og genererer en sfære per unike verdi, der sfærens radius bestemmes av antallet maskiner med sammenfallende verdier.
Sfærene plasseres i en spiralform etter størrelse, hvor de største gruppene utgjør sentrum av spiralen.
Dersom det er flere datasett tilgjengelig i databasen, og en økning eller minking av antall enkeltnoder i en gruppe forekommer, vil det animeres en skalering av sfærens radius i henholdsvis positiv eller negativ retning, sortert på dato fra eldste til nyeste konfigurasjon.
I tillegg vil også sfærenes farge endres, dersom det forekommer andre forandringer i konfigurasjonen til nodene som tilhører en gruppe.
Fargeendringen baserer seg på forholdet mellom antall oppdateringer delt på totalt antall maskiner i en gruppe, og det er mulig å endre hvor stort utslaget skal være i farge, ved å endre variabelen \$changeFactor.

Resultatet vises i figur **sett inn fint bilde her**.

\subsection{DAL.pm}

\begin{verbatim}
Avhengigheter:

DBI 

Konstruktør: new()
Antall parametere: 0
Viktige metodekall:
--??? 
Spesielle variable: 
-pathTilConfigFil...

\end{verbatim}

\end{document}